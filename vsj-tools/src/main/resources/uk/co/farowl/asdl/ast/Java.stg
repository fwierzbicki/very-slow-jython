/*
 * Templates for the generation of Java source from ASDL.
 * 
 * The framework is oriented to the production of ASTs for languages, with the
 * assumption that clients will navigate the tree of class instances using the
 * visitor pattern.
 */

// Java type to use in place of ASDL type (single id)
asdlTypeToJava ::= [
    "identifier" : "String",
    "string" : "String",
    "object" : "Object",
    "constant" : "Object",
    default: key
]

// Java type to use in place of ASDL type (optional or sequence)
asdlTypeToJavaObjectType ::= [
    "identifier" : "String",
    "int" : "Integer",
    "string" : "String",
    "object" : "Object",
    "constant" : "Object",
    default: key
]

// Emit a Java source file for the Abstract Syntax Definition module
main(command, asdlCodeRoot, asdlPackagePath, params) ::= <<
// Generated by <command.tool> from
//      <command.file>
// using template "<command.template>" in group file
//      <command.groupfile>
// with params:
<params: showParam(); separator="\n">
//
<if(asdlPackagePath)>package <asdlPackagePath;separator=".">;<endif>

/**
 * Outer class scoping the types defined in the ASDL module
 * {@code <asdlCodeRoot.name>}.
 */
@SuppressWarnings("javadoc")
public abstract class <asdlCodeRoot.name> {
    /**
     * All definitions in this module implement this interface to
     * support a generic approach to walking the tree.
     */
    public interface Node {
        /**
         * Allows a {@code Visitor} to visit this {@code Node} without knowing
         * its exact type. The {@code Node} dispatches to the appropriate
         * type-specific method of the visitor.
         */
        default \<T> T accept(Visitor\<T> visitor) { return null; }

        /**
         * Collects all the non-null children (members and attributes)
         * of this {@code Node} whose type is also {@code Node}.
         */
        default java.util.Collection\<Node> children() {
            return java.util.Collections.emptyList();
        }
    }

    <asdlCodeRoot.defs: definition(); separator="\n\n">

    public interface Visitor\<T> {
        <asdlCodeRoot.defs: definitionVisit(); separator="\n">
    }

    /**
     * Base class Visitor on the AST, where each method traverses the nodes
     * using {@link Node#accept(Visitor)}, returning the last
     * non-{@code null} result of any child node. Generated leaf nodes all
     * return {@code null}, so the return from any visit is that from the
     * last "user-defined" visit method.
     */
    public static class AbstractVisitor\<T> implements Visitor\<T> {

         /** Last non-null given to setTop() or returned by exit(). */
        private T top = null;

        /** A stack where the top element is the last non-null result. */
        private java.util.LinkedList\<T> stack =
                new java.util.LinkedList\<>();

        /** If argument not null, overwrite the top of stack (no push). */
        protected final void setTop(T t) { if (t != null) { top = t; } };

        /** Get the value at the top of the stack (no pop). */
        protected final T getTop() { return top; }

        /** Call at start of each method where {@link #exit()} is used. */
        protected void enter() { stack.push(top); top = null; }

        /**
         * Call at the very end of each visit method to return the last
         * non-{@code null} result generated by any visit method
         * since {@link #enter()}.
         */
        protected T exit() {
            T t = getTop();
            top = stack.pop();
            return t;
        }

        /**
         * Visit node if not null. Use only with {@link #enter()} and
         * {@link #exit()} unless the type parameter is {@code Void}.
         */
        protected void visitIfNotNull(Node node) {
            if (node != null) { setTop(node.accept(this)); }
        }

        /**
         * Visit all non-null nodes in some collection. Use only with
         * {@link #enter()} and {@link #exit()} unless the type parameter
         * is {@code Void}.
         */
        protected void
                visitAll(java.util.Collection\<? extends Node> nodes) {
            for (Node node : nodes) { visitIfNotNull(node); }
        }

        <asdlCodeRoot.defs: definitionAbsVisitMethods(); separator="\n\n">
    }

}
>>

showParam(p) ::= <%
    //      <p> : <params.(p)>
%>


// ---------------------------------------------------------------------------
// Data model: declaration of classes, fields and constructors
// ---------------------------------------------------------------------------

// Process one definition according to its type to represent it as a class,
// or possibly as an enum.
definition(def) ::= <%
    <if(def.builtin)>
        // <def.name> is a built-in type. (This never happens!)/<\n>
    <elseif(def.sum)>
        <if(def.simple && params.useEnum)>
            /** Represent a {@code <def.name>} as an {@code enum}. */<\n>
            <enumSumDef(def)>
        <else>
            /** Represent a {@code <def.name>} as a union type. */<\n>
            <sumDef(def)>
        <endif>
    <else>
        /** Represent a {@code <def.name>}. */<\n>
        <productDef(def)>
    <endif>
%>

// Declaration of Node class when definition is a product.
// Generates:
//  class declaration
//  fields for members and attributes
//  if members and attributes not empty: constructor
//      initialisers in constructor for members and attributes
//  if any members or attributes are Node type:
//      method children() listing members and attributes (where Node type)
//  method accept(Visitor)
//
productDef(prod) ::= <<
public static class <prod.name><if(params.base)><\\>
        <\ >extends <params.base><endif> implements Node {
    <prod.members: memberDeclaration(); separator="\n">
    <prod.attributes: memberDeclaration(); separator="\n">

    <constructor(prod.name, [prod.members, prod.attributes])>
    <productChildren(prod)>
    public \<T> T accept(Visitor\<T> visitor) {
        return visitor.visit_<prod.name>(this);
    }
}
>>

// Declaration of Java type when definition is implemented by an enum.
// Generates:
//  enum declaration (optionally implements Node, or extends base) with:
//      each constructor-type (name) in the sum as a case.
//  No method accept() since the default in Node will do.
//
enumSumDef(sum) ::= <%
public enum <sum.name><if(params.enumIsNode)> implements Node<endif> {
    <sum.constructors: {c|<c.name>}; separator=", ">
}
%>

// Declaration of Node class when definition is a sum.
// Generates:
//  abstract class declaration
//  fields for attributes
//  if attributes not empty: constructor
//      initialisers in constructor for attributes
//  class declaration for each constructor-type in the sum
//
sumDef(sum) ::= <<
public static abstract class <sum.name><\\>
    <if(params.base)> extends <params.base><endif> implements Node {
    // sum.attributes = <sum.attributes; separator=", ">
    <if(sum.attributes)>
    <sum.attributes: memberDeclaration(); separator="\n">
    <constructor(sum.name, sum.attributes)>
    <endif>
    <sum.constructors: constructorType(sum); separator="\n\n">
}
>>

// One alternative within a sum type definition
// Generates:
//  class declaration for (con) extending the enclosing sum-type (def)
//  fields for members
//  if members and (def) attributes not empty: constructor
//      if (def) attributes not empty, call to super constructor
//      initialisers in constructor for members
//  if any members or attributes are Node type:
//      method children() listing members and attributes (where Node type)
//  method accept(Visitor)
//
constructorType(con, def) ::= <<
public static class <con.name> extends <def.name> {
<if(con.members)>
    // members = <con.members; separator=", ">
    // attributes = <def.attributes; separator=", ">
    <con.members: memberDeclaration(); separator="\n">

    <constructorHead(con.name, [con.members, def.attributes])> {
        <if(def.attributes)>
        super(<def.attributes: {m|<m.name>}; separator=", ">);
        <endif>
        <con.members: memberInitStmt(); separator="\n">
    }

    <constructorTypeChildren(con, def)>
<elseif(def.attributes)>
    // no members
    // attributes = <def.attributes; separator=", ">
    <constructorHead(con.name, def.attributes)> {
        super(<def.attributes: {m|<m.name>}; separator=", ">);
    }

    <constructorTypeChildren(con, def)>
<else>
    // No members, no attributes.
<endif>
    @Override
    public \<T> T accept(Visitor\<T> visitor) {
        return visitor.visit_<con.name>(this);
    }
}
>>

constructor(name, args) ::=<<
<constructorHead(name, args)> {
    <args: memberInitStmt(); separator="\n">
}

>>

memberInitStmt(m) ::= "this.<m.name> = <m.name>;"

memberDeclaration(field) ::= <%
    public <declaredType(field)><" ">
    <field.name>;
%>

// Choose object or collection type according to cardinality
declaredType(field) ::= <%
    <if(field.optional)>
        <asdlTypeToJavaObjectType.(field.type.name)>
    <elseif(field.sequence)>
        java.util.List\<<asdlTypeToJavaObjectType.(field.type.name)>>
    <else>
        <asdlTypeToJava.(field.type.name)>
    <endif>
%>

// Declarative part of a constructor definition
constructorHead(name, args) ::= <%
    public <name>(
    <args: argDecl(); separator=",\n        ">
    )
%>

// Decide whether to specialise the children() method of a constructor-type.
productChildren(prod) ::= <%
    <if(prod.onlyBuiltin)>
        // children(): <prod.name> has only built-in fields<\n>
    <elseif(params.useEnum && !params.enumIsNode && prod.onlySimple)>
        // children(): <prod.name> has only simple (non-node) or built-in fields<\n>
    <else>
        <children([prod.members, prod.attributes])>
    <endif>
%>

// Decide whether to specialise the children() method of a constructor-type.
constructorTypeChildren(con, def) ::= <%
    <if(def.onlyBuiltin && con.onlyBuiltin)>
        // children(): <con.name> has only built-in fields<\n>
    <elseif(params.useEnum && !params.enumIsNode && def.onlySimple && con.onlySimple)>
        // children(): <con.name> has only simple (non-node) or built-in fields<\n>
    <else>
        <children([con.members, def.attributes])>
    <endif>
%>

// Declaration of a field argument (for constructors)
argDecl(field) ::= "<declaredType(field)> <field.name>"

// Implementation of Node::children(). Receives list of members AND attributes.
// Generates:
//  method declaration and a body containing,
//  for each member and each attribute x of Node type:
//      if x is optional an "if not null add()"
//      if x is a sequence, an addAll()
//      otherwise an add()
children(fields) ::= <<
@Override
public java.util.Collection\<Node> children() {
    java.util.List\<Node> list = new java.util.LinkedList\<>();
    <fields: childAdd(); separator="\n">
    return list;
}

>>

childAdd(field) ::= <%
    <if(field.type.builtin)>
        // <field.name> has built-in type <declaredType(field)>
    <elseif(field.type.simple && params.useEnum && !params.enumIsNode)>
        // <field.name> has non-Node type <field.type.name>
    <elseif(field.optional)>
        if (<field.name>!=null) list.add(<field.name>);
    <elseif(field.sequence)>
        list.addAll(<field.name>);
    <else>
        list.add(<field.name>);
    <endif>
%>


// ---------------------------------------------------------------------------
// Visitor interface: declaration of methods
// ---------------------------------------------------------------------------

// Process one definition according to generate the declaration of a visitor
// method in the interface and a default implementation returning null.
//
definitionVisit(def) ::= <%
    <if(def.builtin)>
        // <def.name> is a built-in type. (Should never happen!)
    <elseif(def.sum)>
        <if(def.simple && params.useEnum)>
            <enumSumDefVisit(def)>
        <else>
            <sumDefVisit(def)>
        <endif>
    <else>
        <productDefVisit(def)>
    <endif>
%>

// Declaration of visit method when definition is a product.
productDefVisit(prod) ::= <%
default T visit_<prod.name>(<prod.name> _<prod.name>) { return null; }
%>

// Declaration of visit method when definition is implemented by an enum.
// There is a visit method for the sum itself, not for each constructor-type.
enumSumDefVisit(sum) ::= <%
<if(params.enumIsNode)>
default T visit_<sum.name>(<sum.name> _<sum.name>) { return null; }
<else>
// Not a Node, omit: visit_<sum.name>
<endif>
%>

// Declaration of visit method when definition is a sum.
// There is no visit method for the sum itself, since it is abstract.
sumDefVisit(sum) ::= <%
<sum.constructors: constructorTypeVisit(sum); separator="\n">
%>

// Visit one alternative within a sum type definition
constructorTypeVisit(con, def) ::= <%
default T visit_<con.name>(<def.name>.<con.name> _<con.name>) { return null; }
%>


// ---------------------------------------------------------------------------
// Abstract visitor: default implementation of methods
// ---------------------------------------------------------------------------
//
// Our abstract visitor contains a mechanism that will walk the tree and
// return with whatever was produced by the last (overridden) method that
// return an object. Since only nodes may be visited, there are no visit
// methods non-node members and attributes. We also try hard to avoid
// generating code for types that have only non-node members and attributes.
//
// Default visit method(s) for a definition
definitionAbsVisitMethods(def) ::= <%
    <if(def.builtin)>
        // <def.name> is a built-in type. (This never happens!)/<\n>
    <elseif(def.sum)>
        <if(def.simple && params.useEnum)>
            <enumSumAbsVisitMethod(def)>
        <else>
            <sumAbsVisitMethod(def)>
        <endif>
    <else>
        /** Visit {@code <def.name>} (a product-type in the ASDL). */<\n>
        <productAbsVisitMethod(def)>
    <endif>
%>

// Default visit method when definition is implemented by an enum.
enumSumAbsVisitMethod(sum) ::= <%
    // Visitor.visit_<sum.name> returns null
%>

// Default visit methods when definition is a sum.
sumAbsVisitMethod(sum) ::= <%
    <sum.constructors: constructorAbsVisitMethod(sum); separator="\n">
%>

// Default visit method when definition is a product.
productAbsVisitMethod(prod) ::= <<
public T visit_<prod.name>(<prod.name> _<prod.name>) {
    enter();
    <prod.members: memberAbsVisit(prod); separator="\n">
    return exit();
}
>>

// Default visit method within a sum type definition
constructorAbsVisitMethod(con, def) ::= <<
<if(con.onlyBuiltin)>
// <con.name> has only built-in properties (if any)
<elseif((!params.useEnum || !params.enumIsNode) && con.onlySimple)>
// <con.name> has only simple (non-node) properties
<else>
/** Visit {@code <con.name>} (in ASDL sum-type {@code <def.name>}). */
public T visit_<con.name>(<def.name>.<con.name> _<con.name>) {
    enter();
    <con.members: memberAbsVisit(con); separator="\n">
    return exit();
}
<endif>
>>

memberAbsVisit(field, def) ::= <%
    <if(field.type.builtin)>
        // _<def.name>.<field.name> is not a node
    <elseif(field.type.simple && params.useEnum && !params.enumIsNode)>
        // _<def.name>.<field.name> is not a node
    <else>
        <if(field.optional)>
            visitIfNotNull(_<def.name>.<field.name>);
        <elseif(field.sequence)>
            visitAll(_<def.name>.<field.name>);
        <else>
            setTop(_<def.name>.<field.name>.accept(this));
        <endif>
    <endif>
%>

