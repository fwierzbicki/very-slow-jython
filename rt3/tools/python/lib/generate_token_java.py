#! /usr/bin/env python3
# This script generates token related files from Grammar/Tokens:

from pathlib import Path
from generate_token import NT_OFFSET, load_tokens, update_file, main


# Modified from generate_token to better match Java style indents
def generate_chars_to_token(mapping, nesting=1, level=1):
    result = []
    write = result.append
    tab = "    "
    indent = tab * nesting
    write(tab)
    write(indent)
    write("switch (c%d) {\n" % (level,))
    for c in sorted(mapping):
        write(indent)
        value = mapping[c]
        if isinstance(value, dict):
            write(tab * 2)
            write("case '%s':\n" % (c,))
            write(generate_chars_to_token(value, nesting + 2, level + 1))
            write(indent)
            write(tab * 3)
            write("break;\n")
        else:
            write(tab * 2)
            write("case '%s': return %s;\n" % (c, value))
    write(tab)
    write(indent)
    write("}\n")
    return "".join(result)


token_java_template = """\
/* Auto-generated by src/python/generate_token_java.py */

package uk.co.farowl.vsj3.evo1.parser;

/**
 * This is a translation of CPython's `token.c`.  It provides the various token types.
 *
 * Sources:
 * https://github.com/python/cpython/blob/master/Include/token.h
 * https://github.com/python/cpython/blob/master/Parser/token.c
 */
public enum TokenType {
%s;

    private final int value;
    private final String text;

    TokenType(int value, String text) {
        this.value = value;
        this.text = text;
    }

    TokenType(int value) {
        this.value = value;
        this.text = null;
    }

    public String getText() {
        return this.text;
    }

    public int getTextLength() {
        if (this.text != null)
            return this.text.length();
        else
            return 0;
    }

    public int getValue() {
        return this.value;
    }

    public boolean isTerminal() {
        return this.value < 0x100;
    }

    public boolean isNonTerminal() {
        return this.value >= 0x100;
    }

    public boolean isEOF() {
        return this == ENDMARKER;
    }

    public boolean isWhitespace() {
        return this == ENDMARKER || this == NEWLINE || this == INDENT || this == DEDENT;
    }

    public static TokenType oneChar(char c1) {
%s\
        return OP;
    }

    public static TokenType twoChars(char c1, char c2) {
%s\
        return OP;
    }

    public static TokenType threeChars(char c1, char c2, char c3) {
%s\
        return OP;
    }
}
"""


def make_java(infile, outfile):
    tok_names, ERRORTOKEN, string_to_tok = load_tokens(infile)
    reverse_string_to_tok = {value: key for key, value in string_to_tok.items()}

    defines = []
    for value, name in enumerate(tok_names[: ERRORTOKEN + 1]):
        if reverse_string_to_tok.get(value, False):
            defines.append(
                '\n    %s(%d, "%s")' % (name, value, reverse_string_to_tok[value])
            )
        else:
            defines.append("\n    %s(%d)" % (name, value))

    string_to_tok["<>"] = string_to_tok["!="]
    chars_to_token = {}
    for string, value in string_to_tok.items():
        assert 1 <= len(string) <= 3
        name = tok_names[value]
        m = chars_to_token.setdefault(len(string), {})
        for c in string[:-1]:
            m = m.setdefault(c, {})
        m[string[-1]] = name

    names = []
    for value, name in enumerate(tok_names):
        if value >= ERRORTOKEN:
            name = "<%s>" % name
        names.append('    "%s",\n' % name)
    names.append('    "<N_TOKENS>",\n')

    if update_file(
        outfile,
        token_java_template
        % (
            ",".join(defines),
            generate_chars_to_token(chars_to_token[1]),
            generate_chars_to_token(chars_to_token[2]),
            generate_chars_to_token(chars_to_token[3]),
        ),
    ):
        print("%s regenerated from %s" % (outfile, infile))


def main(
    op="java",
    infile="src/grammar/Tokens",
    outfile="generated/org/python/parser/TokenType.java",
):
    make = globals()["make_" + op]
    infile = Path.cwd() / infile
    outfile = Path.cwd() / outfile
    parent = outfile.parents[0]
    parent.mkdir(parents=True, exist_ok=True)
    make(infile, outfile)


if __name__ == "__main__":
    import sys

    main(*sys.argv[1:])
