package uk.co.farowl.vsj3.evo1;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles.Lookup;

/**
 * A {@code ModuleDef} is a definition from which instances of a module
 * may be made. It stands in relation to the Java classes that define
 * Python modules, somewhat in the way a Python {@code type} object
 * stands in relation to the Java classes that define Python objects.
 * <p>
 * What we most often encounter as "a module", a Python source file, is
 * actually just a definition from which a module object may be made.
 * This happens <i>once in each interpreter</i> where the module is
 * imported. A distinct object, with mutable state, represents that
 * module in each interpreter. There must therefore be a factory object
 * that has access to the definition of the module, but is able to
 * instantiate it (equivalent to executing the body of a module defined
 * in Python). A {@code ModuleDef} is that factory.
 * <p>
 * This initialisation cannot be identified with the static
 * initialisation of the Java class, since that cannot be repeated, but
 * must happen per instance. It is useful, however, to have an
 * intermediate cache of the results of processing the defining Java
 * class once statically initialised.
 */
public class ModuleDef {
    // Compare CPython PyModuleDef

    /** Name of the module. */
    final String name;

    /** The Java class defining instances of the module. */
    final Class<?> definingClass;

    /**
     * Definitions for the members that appear in the dictionary of
     * instances of the module named. Instances receive members by copy,
     * by binding to the module instance (descriptors), or by reference
     * (if immutable).
     */
    private final MethodDef[] methods;

    /**
     * Create a definition for the module, largely by introspection on
     * the class and by forming {@code MethodHandle}s on discovered
     * attributes.
     *
     * @param name of the module (e.g. "sys" or "math")
     * @param lookup authorises access to the defining class.
     */
    ModuleDef(String name, Lookup lookup) {
        this.name = name;
        this.definingClass = lookup.lookupClass();
        ModuleExposer exposer = Exposer.exposeModule(definingClass);
        this.methods = exposer.getMethodDefs(lookup);
        // XXX ... and for fields.
        // XXX ... and for types defined in the module maybe? :o
    }

    /**
     * Get the method definitions. This method is provided for test use
     * only. It isn't safe as for public use.
     *
     * @return the method definitions
     */
    MethodDef[] getMethods() { return methods; }

    /**
     * Add members defined here to the dictionary of a module instance.
     *
     * @param module to populate
     */
    void addMembers(JavaModule module) {
        PyDict d = module.dict;
        for (MethodDef md : methods) {
            // Create function by binding to the module
            ArgParser ap = md.argParser;
            MethodHandle mh = md.handle;
            d.put(md.argParser.name,
                    PyJavaMethod.fromParser(ap, mh, module, this.name));
        }
    }

    /**
     * A {@code MethodDef} describes a built-in function or method as it
     * is declared in a Java module. It holds an argument parser and a
     * handle for calling the method.
     * <p>
     * Recall that a module definition may have multiple instances. The
     * {@code MethodDef} represents the method between the definition of
     * the module (exposure as a {@link ModuleDef}) and the creation of
     * actual {@link JavaModule} instances.
     * <p>
     * When a method is declared in Java as an instance method of the
     * module, the {@code MethodDef} that describes it discounts the
     * {@code self} argument. The {@link PyJavaMethod} created from it
     * binds the module instance that is its target, so that it is is
     * correct for a call to that {@code PyJavaMethod}. This is
     * consistent with CPython.
     */
    // Compare CPython struct PyMethodDef
    static class MethodDef {

        /*
         * The object here is only superficially similar to the CPython
         * PyMethodDef: it is not used as a member of descriptors or
         * methods; extension writers do not declare instances of them.
         * Instead, we reify the argument information from the
         * declaration in Java, and associated annotations. In CPython,
         * this knowledge is present at run-time in the structure of the
         * code generated by Argument Clinic, incompletely in the flags
         * of the PyMethodDef, and textually in the signature that
         * begins the documentation string. We do it by holding an
         * ArgParser.
         */

        /**
         * An argument parser constructed with this {@code MethodDef}
         * from the description of the signature. Full information on
         * the signature is available from this structure, and it is
         * available to parse the arguments to a standard
         * {@code (Object[], String[])} call. (In simple sub-classes it
         * is only used to generate error messages once simple checks
         * fail.)
         */
        final ArgParser argParser;

        /**
         * A handle to the implementation of the function or method.
         * This is generated by reflecting the same object that
         * {@link #argParser} describes.
         */
        // CPython PyMethodDef: ml_meth
        final MethodHandle handle;

        /**
         * Create a {@link MethodDef} of the given kind from the
         * {@link ArgParser} provided.
         *
         * @param argParser parser defining the method
         * @param meth method handle prepared by sub-class
         */
        MethodDef(ArgParser argParser, MethodHandle meth) {
            this.argParser = argParser;
            assert meth != null;
            this.handle = meth;
        }

        @Override
        public String toString() {
            return String.format("%s[%s]", getClass().getSimpleName(),
                    argParser);
        }
    }
}
