package uk.co.farowl.vsj3.evo1;

import static java.lang.invoke.MethodHandles.filterArguments;
import static java.lang.invoke.MethodHandles.filterReturnValue;
import static java.lang.invoke.MethodType.genericMethodType;
import static uk.co.farowl.vsj3.evo1.ClassShorthand.DICT;
import static uk.co.farowl.vsj3.evo1.ClassShorthand.O;
import static uk.co.farowl.vsj3.evo1.ClassShorthand.OA;
import static uk.co.farowl.vsj3.evo1.ClassShorthand.TUPLE;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.invoke.WrongMethodTypeException;
import java.util.ArrayList;
import java.util.List;

import uk.co.farowl.vsj3.evo1.MethodDescriptor.ArgumentError;


/**
 * A {@code MethodDef} describes a built-in function or method as it is
 * declared in Java, and provides mechanisms that support calling it
 * from Python. When an instance method is described by a
 * {@code MethodDef}, the signature discounts the {@code self} argument,
 * so that it is is correct for a call to the bound method, but not (in
 * just this respect) for a call to the descriptor that references it.
 * This is consistent with CPython.
 */
/*
 * We make a significant departure from CPython, in that we reify the
 * argument information as a parser that is a member of this object.
 * This makes the processing of a call to a built-in function quite like
 * a call to one defined in Python. In CPython the information is
 * processed by Argument Clinic into generated source-code.
 */
// Compare CPython struct PyMethodDef
abstract class MethodDef {

    /** The name of the built-in function or method */
    // CPython PyMethodDef: ml_name
    final String name;

    /** A handle to the implementation of the function or method. */
    // CPython PyMethodDef: ml_meth
    final MethodHandle meth;

    /** The {@code __doc__} attribute, or {@code null} */
    final String doc;

    /*
     * Here we depart from CPython in reifying information from the
     * declaration in Java, and associated annotations. In CPython, this
     * knowledge is present at run-time in the structure of the code
     * generated by Argument Clinic, incompletely in the flags of the
     * PyMethodDef, and textually in the signature that begins the
     * documentation string. We do it by holding an ArgParser.
     */

    /**
     * An argument parser constructed with this {@code MethodDef} from
     * the description of the signature. Full information on the
     * signature is available from this structure, and it is available
     * to parse the arguments to
     * {@link #callMethod(MethodHandle, Object, PyTuple, PyDict)} in
     * complex sub-classes of {@code MethodDef}. (In simple sub-classes
     * it is only used to generate error messages once simple checks
     * fail.)
     */
    final ArgParser argParser;

    /**
     * A handle with signature {@code ()O} that throws a single re-used
     * instance of {@code Slot.EmptyException}. We use this in sub-class
     * constructors when given a {@code null} raw method handle, to
     * ensure it is always safe to invoke {@link MethodDef#meth}. If the
     * signature is to be believed, {@code EMPTY} returns
     * {@code Object}, although it never actually returns at all.
     */
    static final MethodHandle EMPTY =
            MethodHandles.throwException(O, Slot.EmptyException.class)
                    .bindTo(new Slot.EmptyException());

    /**
     * Create a {@link MethodDef} of the given kind from the
     * {@link ArgParser} provided.
     *
     * @param argParser parser defining the method
     * @param meth method handle prepared by sub-class
     */
    MethodDef(ArgParser argParser, MethodHandle meth) {
        this.name = argParser.name;
        assert meth != null;  // Check sub-class constructor
        this.meth = meth;
        this.doc = argParser.doc;
        this.argParser = argParser;
    }

    /**
     * Create a {@link MethodDef} from an argument parser. This factory
     * method chooses a specific sub-class of {@code MethodDef}
     * reflecting the parameter "pattern" embedded in the argument
     * parser.
     *
     * @param ap the argument parser
     * @param meth raw method handle by reflection
     * @return a corresponding {@code MethodDef}
     */
    static MethodDef forInstance(ArgParser ap, MethodHandle meth) {
        /*
         * XXX What are the possibilities we can beneficially implement
         * with distinct code paths? The possible signatures of the
         * receiving function in CPython are:
         */
        // METH_NOARGS: m(self)
        // METH_O: m(self, a)
        // METH_FASTCALL: m(self, a, ...)
        // METH_FASTCALL | METH_KEYWORDS: m(self, a, ..., kwnames)
        // METH_VARARGS: m(self, *args)
        // METH_VARARGS | METH_KEYWORDS: m(self, *args, **kwargs)
        // ... or it's an error.
        /*
         * METH_NOARGS and METH_O methods respectively must be called
         * with exactly zero and one argument after self, or will raise
         * an error. There is no possibility of defaults making up a
         * trailing shortfall.
         *
         * In other cases argument numbers are not checked in the call,
         * but in the Argument Clinic wrapper on the method. If it
         * chooses, the wrapper may supply default values in the program
         * text, and/or collect excess arguments supplied positionally
         * in a tuple.
         *
         * Only two (with METH_KEYWORDS) allow arguments to be given by
         * keyword. Where no keyword arguments are allowed, there can be
         * no keyword-only parameters or keyword defaults. Where
         * keywords are allowed, the called method may choose to collect
         * excess keywords arguments in a dictionary.
         */

        // XXX Decide what MethodDef subclasses are needed.
        // (Consider the call one might make from Java.)

        // if (!ap.hasVarKeywords()) {
        // if (!ap.hasVarArgs()) {
        // if (ap.kwonlyargcount == 0) {
        // if (ap.posonlyargcount == ap.argcount) {
        // // All arguments must be given by position
        // if (ap.argcount == 0) {
        // return new NoArgs(ap);
        // } else if (ap.argcount == 1) {
        // return new OneArg(ap);
        // } else if (defaults == null) {
        // return new Positional(ap);
        // } else {
        // ap.defaults(defaults);
        // return new PositionalOptional(ap, defaults);
        // }
        // }
        // }
        // }
        // }

        // Fall back to the general case
        return new General(ap, meth);
    }

    /**
     * Invoke the given method handle for the given target {@code self},
     * and classic arguments ({@code tuple} and {@code dict}) having
     * arranged the arguments as expected by the method. We create
     * sub-classes of {@link MethodDef} to represent the finite
     * repertoire of {@code MethodType}s to which exposed methods may be
     * converted by the {@link Exposer}. This method accepts arguments
     * in a generic way (from the interpreter, say) and adapts them to
     * the specific needs of a wrapped method. The caller guarantees
     * that the wrapped method has the {@code MethodType} to which the
     * call is addressed.
     *
     * @param method handle of the method to call
     * @param self target object of the method call
     * @param args of the method call
     * @param kwargs of the method call or {@code null} or empty
     * @return result of the method call
     * @throws TypeError when the arguments ({@code args},
     *     {@code kwargs}) are not correct for the {@code MethodType}
     * @throws Throwable from the implementation of the special method
     */
    // Compare CPython wrap_* in typeobject.c
    abstract Object callMethod(MethodHandle method, Object self,
            PyTuple args, PyDict kwargs) throws TypeError, Throwable;

    /**
     * Invoke the given method handle for the given target {@code self},
     * and vector arguments ({@code Object[]} and {@code dict}) having
     * arranged the arguments as expected by the method. We create
     * sub-classes of {@link MethodDef} to represent the finite
     * repertoire of {@code MethodType}s to which exposed methods may be
     * converted by the {@link Exposer}. This method accepts arguments
     * in a generic way (from the interpreter, say) and adapts them to
     * the specific needs of a wrapped method. The caller guarantees
     * that the wrapped method has the {@code MethodType} to which the
     * call is addressed.
     *
     * @param method handle of the method to call
     * @param self target object of the method call
     * @param args of the method call
     * @param names of args given by keyword or {@code null}
     * @return result of the method call
     * @throws TypeError when the arguments ({@code args},
     *     {@code kwargs}) are not correct for the {@code MethodType}
     * @throws Throwable from the implementation of the special method
     */
    // Compare CPython wrap_* in typeobject.c
    abstract Object callMethod(MethodHandle method, Object self,
            Object[] args, String[] names) throws TypeError, Throwable;

    /**
     * Each sub-type of {@link MethodDef} implements
     * {@code callMethod(mh, self, args, kwargs)} in its own way, and
     * must prepare the method handle to accept the number and type of
     * arguments it will supply. Typically, the returned handle will
     * expect a "self" object and an array of objects, but not
     * universally.
     *
     * @param raw the handle to be prepared
     * @return handle compatible with {@code methodDef}
     */
    abstract MethodHandle prepare(MethodHandle raw);

    /**
     * Adapt an arbitrary method handle to one that expects arguments
     * from a given position onwards to be {@code Object}, and returns
     * {@code Object}, using the conversions defined in {@link Clinic}.
     *
     * @param raw the handle to be prepared (or null for empty)
     * @param pos index in the type at which to start.
     * @return handle compatible with {@code methodDef}
     */
    static final MethodHandle adapt(MethodHandle raw, int pos)
            throws WrongMethodTypeException {
        /*
         * To begin with, adapt the arguments after self to expect a
         * java.lang.Object, if Clinic knows how to convert them.
         */
        MethodType mt = raw.type();
        MethodHandle[] af = Clinic.argumentFilter(mt, pos);
        MethodHandle mh = filterArguments(raw, pos, af);
        MethodHandle rf = Clinic.returnFilter(mt);
        if (rf != null) { mh = filterReturnValue(mh, rf); }
        /*
         * Let the method definition enforce specific constraints and
         * conversions on the handle.
         */
        return mh;
    }

    /**
     * From the given argument parser, create a method type that
     * reflects it. This is a helper for constructors of sub-classes of
     * {@link MethodDef} where they need the type to which {@link #meth}
     * should conform.
     *
     * @param ap argument parser to interrogate
     * @return method type reflecting the parser
     */
    protected static MethodType methodType(ArgParser ap) {
        List<Class<?>> ptypes = new ArrayList<>(10);
        if (ap.methodKind != MethodKind.STATIC) { ptypes.add(O); }
        for (int i = 0; i < ap.regargcount; i++) { ptypes.add(O); }
        if (ap.hasVarArgs()) { ptypes.add(TUPLE); }
        if (ap.hasVarKeywords()) { ptypes.add(DICT); }
        return MethodType.methodType(O, ptypes);
    }

    private static final String ARG_NOT_CONVERTIBLE =
            "in %s argument '%s' is not convertible from Object";

    @Override
    public String toString() {
        return String.format("%s [%s]", argParser,
                getClass().getSimpleName());
    }

    /**
     * All the argument types (from the given position on) in the type
     * of the given handle should be {@code Object.class}. If they
     * aren't, it is because no conversion was available in
     * {@link Clinic#argumentFilter(MethodType, int)}.
     *
     * @param mh {@code .type()[pos:]} handle to check
     * @param pos first element to check
     */
    protected void checkConvertible(MethodHandle mh, int pos) {
        MethodType mt = mh.type();
        int n = mt.parameterCount();
        for (int i = pos; i < n; i++) {
            if (mt.parameterType(i) != O) {
                throw new InterpreterError(ARG_NOT_CONVERTIBLE, name,
                        argParser.argnames[i]);
            }
        }
    }

    /**
     * Check that no positional or keyword arguments are supplied. This
     * is for use when implementing
     * {@link #callMethod(MethodHandle, Object, PyTuple, PyDict)}.
     *
     * @param args positional argument tuple to be checked
     * @param kwargs to be checked {@code null} or empty
     * @throws TypeError if positional arguments are given or
     *     {@code kwargs} is not {@code null} or empty
     */
    final protected void checkNoArgs(PyTuple args, PyDict kwargs)
            throws TypeError {
        if (args.value.length != 0
                || (kwargs != null && !kwargs.isEmpty())) {
            // This will raise the TypeError by a slow path
            argParser.parse(args, kwargs);
        }
    }

    /**
     * Check the number of positional arguments and that no keywords are
     * supplied. This is for use when implementing
     * {@link #callMethod(MethodHandle, Object, PyTuple, PyDict)}.
     *
     * @param args positional argument tuple to be checked
     * @param expArgs expected number of positional arguments
     * @param kwargs to be checked {@code null} or empty
     * @throws TypeError if the wrong number of positional arguments are
     *     given or {@code kwargs} is not {@code null} or empty
     */
    final protected void checkArgs(PyTuple args, int expArgs,
            PyDict kwargs) throws TypeError {
        if (args.value.length != expArgs
                || (kwargs != null && !kwargs.isEmpty())) {
            // This will raise the TypeError by a slow path
            argParser.parse(args, kwargs);
        }
    }

    /**
     * Check the number of positional arguments and that no keywords are
     * supplied. This is for use when implementing
     * {@link #callMethod(MethodHandle, Object, PyTuple, PyDict)}.
     *
     * @param args positional argument tuple to be checked
     * @param minArgs minimum number of positional arguments
     * @param maxArgs maximum number of positional arguments
     * @param kwargs to be checked {@code null} or empty
     * @throws TypeError if the wrong number of positional arguments are
     *     given or {@code kwargs} is not {@code null} or empty
     */
    final protected void checkArgs(PyTuple args, int minArgs,
            int maxArgs, PyDict kwargs) throws TypeError {
        int n = args.value.length;
        if (n < minArgs || n > maxArgs
                || (kwargs != null && !kwargs.isEmpty())) {
            // This will raise the TypeError by a slow path
            argParser.parse(args, kwargs);
        }
    }

    /** A method with signature {@code (O)O}. */
    static class NoArgs extends MethodDef {

        private static MethodType GENERIC = genericMethodType(1);

        NoArgs(ArgParser ap, MethodHandle raw) {
            super(ap, prep(raw));
        }

        /**
         * Prepare a provided raw method handle, consistent with this
         * sub-class, e.g. from {@code Lookup.unreflect}, so that it
         * matches the type {@link #GENERIC}.
         *
         * @param raw handle representing the Java implementation
         * @return handle suitable to be {@link MethodDef#meth}
         */
        private static MethodHandle prep(MethodHandle raw) {
            if (raw == null)
                return MethodHandles.dropArguments(EMPTY, 0,
                        GENERIC.parameterList());
            else
                return adapt(raw, 1).asType(GENERIC);
        }

        @Override
        MethodHandle prepare(MethodHandle raw) {
            return prep(raw);
        }

        @Override
        Object callMethod(MethodHandle method, Object self,
                PyTuple args, PyDict kwargs)
                throws ArgumentError, Throwable {
            checkNoArgs(args, kwargs);
            return method.invokeExact(self);
        }

        @Override
        Object callMethod(MethodHandle method, Object self,
                Object[] args, String[] names)
                throws TypeError, Throwable {

            return null;
        }
    }

    /** A method with signature {@code (O,O)O}. */
    static class OneArg extends MethodDef {

        private static MethodType GENERIC = genericMethodType(2);

        OneArg(ArgParser ap, MethodHandle raw) {
            super(ap, prep(raw));
        }

        /**
         * Prepare a provided raw method handle, consistent with this
         * sub-class, e.g. from {@code Lookup.unreflect}, so that it
         * matches the type {@link #GENERIC}.
         *
         * @param raw handle representing the Java implementation
         * @return handle suitable to be {@link MethodDef#meth}
         */
        private static MethodHandle prep(MethodHandle raw) {
            if (raw == null)
                return MethodHandles.dropArguments(EMPTY, 0,
                        GENERIC.parameterList());
            else
                return adapt(raw, 1).asType(GENERIC);
        }

        @Override
        MethodHandle prepare(MethodHandle raw) {
            return prep(raw);
        }

        @Override
        Object callMethod(MethodHandle method, Object self,
                PyTuple args, PyDict kwargs)
                throws ArgumentError, Throwable {
            checkArgs(args, 1, kwargs);
            return method.invoke(self, args.value[0]);
        }

        @Override
        Object callMethod(MethodHandle method, Object self,
                Object[] args, String[] names)
                throws TypeError, Throwable {

            return null;
        }
    }

    /**
     * A method with signature {@code (O,O[])O} where the arguments to a
     * call must match exactly the number of positional parameters.
     */
    static class Positional extends MethodDef {

        private static MethodType GENERIC = genericMethodType(1, true);

        Positional(ArgParser ap, MethodHandle raw) {
            super(ap, prep(raw));
        }

        /**
         * Prepare a provided raw method handle, consistent with this
         * sub-class, e.g. from {@code Lookup.unreflect}, so that it
         * matches the type {@link #GENERIC}.
         *
         * @param raw handle representing the Java implementation
         * @return handle suitable to be {@link MethodDef#meth}
         */
        private static MethodHandle prep(MethodHandle raw) {
            if (raw == null)
                return MethodHandles.dropArguments(EMPTY, 0,
                        GENERIC.parameterList());
            else {
                int n = raw.type().parameterCount() - 1;
                return adapt(raw, 1).asSpreader(Object[].class, n)
                        .asType(GENERIC);
            }
        }

        @Override
        MethodHandle prepare(MethodHandle raw) {
            return prep(raw);
        }

        @Override
        Object callMethod(MethodHandle method, Object self,
                PyTuple args, PyDict kwargs)
                throws ArgumentError, Throwable {
            checkArgs(args, argParser.posonlyargcount, kwargs);
            return method.invoke(self, args.value);
        }

        @Override
        Object callMethod(MethodHandle method, Object self,
                Object[] args, String[] names)
                throws TypeError, Throwable {

            return null;
        }
    }

    /**
     * An instance method with signature {@code (O,[O])O}, accepting
     * arguments by position or keyword, and where the {@link MethodDef}
     * provides default values for some parameters by positional and
     * keyword defaults. The handle leads to the implementation method,
     * supplied as a handle in the constructor, but with casts that
     * ensure a match with the declared arguments. In an instance
     * method, or a class method, the first argument is supplied as the
     * first argument to the implementation method. In a static method,
     * the first argument is discarded (and may be
     * {@code null}).
     */
    static class General extends MethodDef {

        // TODO adapt code for fully general case.

        private static MethodType GENERIC = genericMethodType(1, true);

        /**
         * An instance method where the signature of the raw
         * implementation is fully general, limited only by the ,
         * signature {@code (O, O..., )O}.
         *
         * @param argParser parser defining the method
         * @param raw method handle prepared by sub-class
         */
        General(ArgParser argParser, MethodHandle raw) {
            super(argParser, prep(argParser, raw));
        }

        /**
         * Prepare a provided raw method handle, consistent with this
         * sub-class, e.g. from {@code Lookup.unreflect}, so that it
         * matches the type implied by the parser.
         *
         * @param ap to which the handle is made to conform
         * @param raw handle representing the Java implementation
         * @return handle suitable to be {@link MethodDef#meth}
         */
        private static MethodHandle prep(ArgParser ap,
                MethodHandle raw) {
            if (raw == null) {
                // Give the EMPTY handle the signature (O,[O])O
                return MethodHandles.dropArguments(EMPTY, 0, O, OA);
            } else {
                MethodHandle mh;
                if (ap.methodKind == MethodKind.STATIC) {
                    // No self parameter: start at zero
                    mh = adapt(raw, 0);
                    // Discard the self argument that we pass
                    mh = MethodHandles.dropArguments(mh, 0, O);
                } else {
                    // Skip self parameter: start at one
                    mh = adapt(raw, 1);
                }
                // We will present the last n args as an array
                int n = ap.argnames.length;
                mh = mh.asSpreader(OA, n);
                return mh.asType(GENERIC);
            }
        }

        @Override
        MethodHandle prepare(MethodHandle raw) {
            // The method handle type must be {@code (O,[O])O}
            return prep(argParser, raw);
        }

        @Override
        Object callMethod(MethodHandle method, Object self,
                PyTuple args, PyDict kwargs)
                throws ArgumentError, Throwable {
            assert method.type() == meth.type();
            /*
             * The method handle type is {@code (O,[O])O}. The parser
             * will make an array of the args, kwargs, and where
             * allowed, gather excess arguments into a tuple or dict,
             * and fill missing ones from defaults.
             */
            Object[] frame = argParser.parse(args, kwargs);
            return method.invoke(self, frame);
        }

        @Override
        Object callMethod(MethodHandle method, Object self,
                Object[] args, String[] names)
                throws TypeError, Throwable {
            // XXX Implement

            return null;
        }
    }
}
