package uk.co.farowl.vsj3.evo1;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.invoke.WrongMethodTypeException;
import java.util.List;

import uk.co.farowl.vsj3.evo1.PyType.Flag;
import uk.co.farowl.vsj3.evo1.Slot.EmptyException;
import uk.co.farowl.vsj3.evo1.base.InterpreterError;
import uk.co.farowl.vsj3.evo1.base.MethodKind;

/**
 * Descriptor for a method defined in Java, that is to be called from
 * Python. A {@code PyMethodDescr} is a callable object itself, and
 * provides binding behaviour through {@link #__get__(Object, PyType)
 * __get__}, which usually creates a {@link PyJavaMethod}.
 * <p>
 * It suits us to sub-class {@code PyMethodDescr} to express the
 * multiplicity of implementations and to respond to the signature of
 * the method, optimising its data flow to arguments. Instances are
 * therefore obtained by calling
 * {@link PyMethodDescr#fromParser(PyType, ArgParser, List) fromParser}.
 */
abstract class PyMethodDescr extends MethodDescriptor {

    static final PyType TYPE = PyType.fromSpec(
            new PyType.Spec("method_descriptor", MethodHandles.lookup())
                    .flagNot(Flag.BASETYPE)
                    .flag(Flag.IS_METHOD_DESCR, Flag.IS_DESCR));

    /*
     * We depart from CPython in reifying information from the Java
     * declaration and associated annotations, not as a separate
     * PyMethodDef but in the PyMethodDescr itself and in an attached
     * argument parser. In CPython, the same information is present at
     * run-time in the structure of the code itself, generated by
     * Argument Clinic, in the flags of the PyMethodDef, and as text in
     * the signature that begins the documentation string.
     */

    /**
     * An argument parser supplied to this {@code PyMethodDescr} at
     * construction, from Java reflection of the implementation and from
     * annotations on it. Full information on the signature is available
     * from this structure, and it is available to parse the arguments
     * to {@link #__call__(Object[], String[])} for methods with a
     * complex signature. (In sub-classes that represent methods with a
     * simple signature, it is only used to generate error messages once
     * validity checks fail.)
     */
    final ArgParser argParser;

    /**
     * A handle to the implementation of the function or method. In the
     * general case, this handle has signature {@code (O,[O])O}, and
     * expects a "self" object and an array of arguments, but not in
     * optimised cases.
     * <p>
     * Sub-classes where {@code objclass} has multiple accepted
     * implementations, supersede {@code method} with an array, and
     * place here only a default that throws {@link EmptyException}.
     */
    // CPython PyMethodDef::ml_meth
    final MethodHandle method;

    /**
     * Deduced method signature (useful to have cached when constructing
     * a {@link PyJavaMethod}). Note that this is allowed to differ from
     * {@link MethodSignature#fromParser(ArgParser)
     * MethodSignature.fromParser(argParser)}.
     */
    final MethodSignature signature;

    /**
     * Construct a base method descriptor, identifying the
     * implementation by a parser and a method handle.
     *
     * @param objclass the class declaring the method
     * @param argParser describing the signature of the method
     * @param signature to which to coerce the handle
     * @param method handle to invoke the wrapped method
     */
    // Compare CPython PyDescr_NewMethod in descrobject.c
    protected PyMethodDescr(PyType objclass, ArgParser argParser,
            MethodSignature signature, MethodHandle method) {
        super(TYPE, objclass, argParser.name);
        this.argParser = argParser;
        this.signature = signature;
        this.method = signature.prepare(argParser, method);
    }

    /**
     * Construct a base method descriptor where that throws an empty
     * slot exception, identifying the implementation by a parser.
     *
     * @param objclass the class declaring the method
     * @param argParser describing the signature of the method
     * @param signature to which {@code method} conforms
     */
    // Compare CPython PyDescr_NewMethod in descrobject.c
    protected PyMethodDescr(PyType objclass, ArgParser argParser,
            MethodSignature signature) {
        super(TYPE, objclass, argParser.name);
        this.argParser = argParser;
        this.signature = signature;
        this.method = signature.empty;
    }

    /**
     * Construct a {@code PyMethodDescr} from an {@link ArgParser} and
     * {@code MethodHandle}s for the implementation methods. The
     * arguments described by the parser do not include "self".
     * <p>
     * In the most common case, where {@code objclass} has only one
     * accepted implementation, there will be only one handle in the
     * {@code candidates} list. Where {@code objclass} has multiple
     * accepted implementations, {@code candidates} may have one entry
     * for each, although it is possible for a single entry with
     * {@code Object self}.
     *
     * @param objclass owning class
     * @param ap argument parser (provides name etc.)
     * @param candidates method handles for the implementations
     * @return a method descriptor supporting the signature
     */
    // Compare CPython PyDescr_NewMethod in descrobject.c
    static PyMethodDescr fromParser(PyType objclass, ArgParser ap,
            List<MethodHandle> candidates) {
        assert ap.methodKind == MethodKind.INSTANCE;
        /*
         * Note this is a recommendation on the assumption all
         * optimisations are supported. The actual choice is made in the
         * switch statement.
         */
        MethodSignature sig = MethodSignature.fromParser(ap);

        try {
            if (objclass.acceptedCount == 1 && candidates.size() == 1) {
                /*
                 * Wrap the single candidate implementation of this
                 * method for the single accepted implementation of
                 * objclass. This is the most common case.
                 */
                MethodHandle mh = candidates.get(0);
                switch (sig) {
                    case NOARGS:
                        return new NoArgs(objclass, ap, mh);
                    case O1:
                    case O2:
                    case O3:
                    case POSITIONAL:
                        return new Positional(objclass, ap, mh);
                    default:
                        return new General(objclass, ap, mh);
                }
            } else {
                /*
                 * There are multiple accepted implementations of
                 * objclass. The constructors here match them to
                 * candidate implementations of ap. (We also land here
                 * if there is not exactly one candidate, relying on the
                 * search for one to fail and throw InternalError.)
                 */
                switch (sig) {
                    case NOARGS:
                        return new Multiple.NoArgs(objclass, ap,
                                candidates);
                    case O1:
                    case O2:
                    case O3:
                    case POSITIONAL:
                        return new Multiple.Positional(objclass, ap,
                                candidates);
                    default:
                        return new Multiple.General(objclass, ap,
                                candidates);
                }
            }
        } catch (WrongMethodTypeException wmte) {
            throw new InterpreterError(wmte,
                    "Failed to create descriptor for '%s.%s'",
                    objclass.name, ap.name);
        }
    }

    /**
     * Invoke the wrapped method handle for the given target
     * {@code self}, and standard arguments ({@code Object[]} and
     * {@code String[]}). The implementation will arrange the arguments
     * as expected by the handle, or throw if they are not correct for
     * that. In the general case, a call to {@link #argParser} is
     * involved. We create sub-classes of {@link PyMethodDescr} to
     * represent the finite repertoire of {@code MethodSignature}s, that
     * override this method with simplified logic.
     *
     * @param self target object of the method call
     * @param args of the method call
     * @param names of args given by keyword or {@code null}
     * @return result of the method call
     * @throws TypeError when the arguments ({@code args},
     *     {@code kwargs}) are not correct for the method signature
     * @throws ArgumentError as a shorthand for {@link TypeError}, which
     *     the caller must convert with
     *     {@link MethodDescriptor#typeError(ArgumentError, Object[])}
     * @throws Throwable from the implementation of the special method
     */
    // Compare CPython method_vectorcall_* in descrobject.c
    abstract Object callMethod(Object self, Object[] args,
            String[] names) throws ArgumentError, TypeError, Throwable;

    /**
     * Return the handle contained in this descriptor applicable to the
     * Java class of a {@code self} argument during a call.
     * {@code self==null} is acceptable only in sub-classes where
     * {@code objclass} has a single accepted implementation or the
     * method is Python static.
     * <p>
     * Sub-classes where {@code objclass} has multiple accepted
     * implementations, override this method, because they supersede
     * {@link #method} with an array. The {@link Descriptor#objclass} is
     * consulted to make this determination. If the class of
     * {@code self} is not an accepted implementation of
     * {@code objclass}, an empty slot handle (with the correct
     * signature) is returned.
     *
     * @param self the {@code self} argument in some call
     * @return corresponding handle (or one that throws
     *     {@link EmptyException})
     */
    MethodHandle getHandle(Object self) {
        // The first argument is acceptable as 'self'
        assert argParser.methodKind == MethodKind.STATIC
                || self != null && objclass.getJavaClass()
                        .isAssignableFrom(self.getClass());
        return method;
    }

    // CPython get-set table (to convert to annotations):
    // private GetSetDef method_getset[] = {
    // {"__doc__", (getter)method_get_doc},
    // {"__qualname__", (getter)descr_get_qualname},
    // {"__text_signature__", (getter)method_get_text_signature},
    // {0}
    // };

    // CPython type object (to convert to special method names):
    // PyType PyMethodDescr_Type = {
    // PyVar_HEAD_INIT(&PyType_Type, 0)
    // "method_descriptor",
    // sizeof(PyMethodDescr),
    // 0,
    // offsetof(PyMethodDescr, vectorcall), /* tp_vectorcall_offset */
    // (reprfunc)method_repr, /* tp_repr */
    // PyVectorcall_Call, /* tp_call */
    // PyObject_GenericGetAttr, /* tp_getattro */
    // Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
    // _Py_TPFLAGS_HAVE_VECTORCALL |
    // Py_TPFLAGS_METHOD_DESCRIPTOR, /* tp_flags */
    // descr_methods, /* tp_methods */
    // descr_members, /* tp_members */
    // method_getset, /* tp_getset */
    // (descrgetfunc)method_get, /* tp_descr_get */
    // };

    // special methods ------------------------------------------------

    // Compare CPython method_repr in descrobject.c
    Object __repr__() { return descrRepr("method"); }

    /**
     * Invoke the Java method this method descriptor points to, using
     * arguments derived from the standard {@code __call__} arguments
     * supplied, default arguments and other information described for
     * the method.
     *
     * @param args all arguments beginning with {@code self}
     * @param names of keyword arguments
     * @return result of calling the wrapped method
     * @throws TypeError if {@code args[0]} is the wrong type
     * @throws Throwable from the implementation of the special method
     */
    @Override
    public Object __call__(Object[] args, String[] names)
            throws TypeError, Throwable {

        int argc = args.length;
        if (argc > 0) {
            // Split the leading element self from args
            Object self = args[0];
            Object[] newargs;
            if (argc == 1) {
                newargs = Py.EMPTY_ARRAY;
            } else {
                newargs = new Object[argc - 1];
                System.arraycopy(args, 1, newargs, 0, newargs.length);
            }

            // Make sure that the first argument is acceptable as 'self'
            PyType selfType = PyType.of(self);
            if (!Abstract.recursiveIsSubclass(selfType, objclass)) {
                throw new TypeError(DESCRIPTOR_REQUIRES, name,
                        objclass.name, selfType.name);
            }

            try {
                // Invoke the wrapped method.
                return callMethod(self, newargs, names);
            } catch (ArgumentError ae) {
                /*
                 * Implementations may throw ArgumentError as a
                 * simplified encoding of a TypeError.
                 */
                throw typeError(ae, newargs);
            }

        } else {
            // Not even one argument
            throw new TypeError(DESCRIPTOR_NEEDS_ARGUMENT, name,
                    objclass.name);
        }
    }

    /**
     * Call with self already distinguished, an array of all the
     * argument values (after the self argument) and an array of the
     * names of those given by keyword.
     *
     * @param self target object of the method call
     * @param args arguments of the method call
     * @param names of arguments given by keyword (may be {@code null}
     *     if empty)
     * @return result of the method call
     * @throws TypeError if the arguments do not fit the method
     * @throws Throwable from the implementation of the method
     */
    public Object call(Object self, Object[] args, String[] names)
            throws Throwable {

        if (self == null) {
            // Not even the self argument
            throw new TypeError(DESCRIPTOR_NEEDS_ARGUMENT, name,
                    objclass.name);

        } else {
            // Manage the argument vector and names into classic form
            if (args == null) {
                // No arguments (easy)
                args = Py.EMPTY_ARRAY;
                names = null;
            } else if (names != null && names.length == 0) {
                names = null;
            }

            // Make sure that the first argument is acceptable as 'self'
            PyType selfType = PyType.of(self);

            if (!Abstract.recursiveIsSubclass(selfType, objclass)) {
                throw new TypeError(DESCRIPTOR_REQUIRES, name,
                        objclass.name, selfType.name);
            }

            try {
                // Call through the correct wrapped handle
                return callMethod(self, args, names);
            } catch (ArgumentError ae) {
                /*
                 * Implementations may throw ArgumentError as a
                 * simplified encoding of a TypeError.
                 */
                throw typeError(ae, args);
            }
        }
    }

    /**
     * Return the described method, bound to {@code obj} as its "self"
     * argument, or if {@code obj==null}, return this descriptor. In the
     * non-null case, {@code __get__} returns a {@link PyJavaMethod}.
     * Calling the returned object invokes the same Java method as this
     * descriptor, with {@code obj} as first argument, and other
     * arguments to the call appended.
     *
     * @param obj target (self) of the method, or {@code null}
     * @param type ignored
     * @return method bound to {@code obj} or this descriptor.
     */
    @Override
    // Compare CPython method_get in descrobject.c
    Object __get__(Object obj, PyType type) {
        if (obj == null)
            // Return the descriptor itself.
            return this;
        else {
            // Return a callable binding the method and the target
            check(obj);
            return PyJavaMethod.from(this, obj);
        }
    }

    // exposed methods -----------------------------------------------

    /** @return name of the function or method */
    // Compare CPython meth_get__name__ in methodobject.c
    @Exposed.Getter
    String __name__() { return argParser.name; }

    // Compare CPython method_get_doc in descrobject.c
    Object get_doc() {
        return PyType.getDocFromInternalDoc(__name__(), argParser.doc);
    }

    // Compare CPython method_get_text_signature in descrobject.c
    Object get_text_signature() {
        return PyType.getTextSignatureFromInternalDoc(__name__(),
                argParser.doc);
    }

    // plumbing ------------------------------------------------------

    /**
     * Construct an array of method handles, one for each accepted
     * implementation of {@code objclass}, working from a list of
     * candidate method handles.
     *
     * @param sig handle type information distilled from parser
     * @param candidates handles on which to base return
     * @return method handles aligned to {@code objclass.clases}
     */
    protected MethodHandle[] prepareCandidates(MethodSignature sig,
            List<MethodHandle> candidates) {

        final int N = objclass.acceptedCount;
        MethodHandle[] methods = new MethodHandle[N];

        // Fill the method array with matching method handles
        for (int i = 0; i < N; i++) {
            // Seek most specific match for the i.th accepted class
            Class<?> ac = objclass.classes[i];
            MethodHandle match = null;
            // The candidates are sorted most specific first
            for (MethodHandle mh : candidates) {
                MethodType mt = mh.type();
                if (mt.parameterType(0).isAssignableFrom(ac)) {
                    match = mh;
                    break;
                }
            }

            if (match != null) {
                /*
                 * Prepare the implementation handle to match the
                 * invocation type in callMethod.
                 */
                methods[i] = sig.prepare(argParser, match);
            } else {
                // No match means no implementation we can use
                throw new InterpreterError(
                        "'%s.%s' not implemented for %s", objclass.name,
                        __name__(), objclass.classes[i]);
            }
        }
        return methods;
    }

    /**
     * The implementation may have any signature allowed by
     * {@link ArgParser}.
     */
    private static class General extends PyMethodDescr {
        /**
         * Construct a method descriptor, identifying the implementation
         * by a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param method raw handle to invoke the method
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        General(PyType objclass, ArgParser argParser,
                MethodHandle method) {
            super(objclass, argParser, MethodSignature.GENERAL, method);
        }

        /**
         * Construct an "empty" {@link General} method descriptor.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         */
        protected General(PyType objclass, ArgParser argParser) {
            super(objclass, argParser, MethodSignature.GENERAL);
        }

        @Override
        Object callMethod(Object self, Object[] args, String[] names)
                throws TypeError, Throwable {
            /*
             * The method handle type is {@code (O,O[])O}. The parser
             * will make an array of the args, and where allowed, gather
             * excess arguments into a tuple or dict, and fill missing
             * ones from defaults.
             */
            Object[] frame = argParser.parse(args, names);
            return method.invokeExact(self, frame);
        }
    }

    /**
     * The implementation signature accepts no arguments after
     * {@code self}.
     */
    private static class NoArgs extends PyMethodDescr {
        /**
         * Construct a method descriptor, identifying the implementation
         * by a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param method handle to invoke the wrapped method
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        NoArgs(PyType objclass, ArgParser argParser,
                MethodHandle method) {
            super(objclass, argParser, MethodSignature.NOARGS, method);
            assert objclass.acceptedCount == 1;
        }

        /**
         * Construct an "empty" {@link NoArgs} method descriptor.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         */
        protected NoArgs(PyType objclass, ArgParser argParser) {
            super(objclass, argParser, MethodSignature.NOARGS);
        }

        @Override
        Object callMethod(Object self, Object[] args, String[] names)
                throws TypeError, Throwable {
            // The method handle type is {@code (O)O}.
            checkNoArgs(args, names);
            return method.invokeExact(self);
        }
    }

    /**
     * The implementation signature accepts a number of positional
     * arguments after {@code self}, with potential trailing defaults,
     * specified by the parser.
     */
    private static class Positional extends PyMethodDescr {

        /** Default values of the trailing arguments. */
        protected final Object[] defaults;

        /**
         * Construct a method descriptor, identifying the implementation
         * by a parser and a method handle.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         * @param method handle to invoke the wrapped method
         */
        // Compare CPython PyDescr_NewMethod in descrobject.c
        Positional(PyType objclass, ArgParser argParser,
                MethodHandle method) {
            super(objclass, argParser, MethodSignature.POSITIONAL,
                    method);
            assert objclass.acceptedCount == 1;
            this.defaults = argParser.getDefaults();
        }

        /**
         * Construct an "empty" {@link Positional} method descriptor.
         *
         * @param objclass the class declaring the method
         * @param argParser describing the signature of the method
         */
        protected Positional(PyType objclass, ArgParser argParser) {
            super(objclass, argParser, MethodSignature.POSITIONAL);
            this.defaults = argParser.getDefaults();
        }

        @Override
        Object callMethod(Object self, Object[] args, String[] names)
                throws TypeError, Throwable {
            // The method handle type is {@code (O,O[])O}.
            MethodHandle wrapped = getHandle(self);
            int max = argParser.argcount;
            int min = max - defaults.length;
            checkArgs(args, min, max, names);
            // May need to fill a gap from defaults
            int n = args.length, gap = max - n;
            if (gap == 0) {
                return wrapped.invokeExact(self, args);
            } else {
                Object[] frame = new Object[max];
                System.arraycopy(args, 0, frame, 0, n);
                System.arraycopy(defaults, n - min, frame, n, gap);
                return wrapped.invokeExact(self, frame);
            }
        }
    }

    /**
     * A name space for sub-classes of {@link PyMethodDescr} to use for
     * an instance method when the owning Python type has multiple
     * accepted implementations.
     */
    private static class Multiple {

        /**
         * A variant of {@link PyMethodDescr.General} that allows for
         * multiple accepted implementations of {@code objclass}.
         */
        private static class General extends PyMethodDescr.General {
            /**
             * Handles for the particular implementations of a method.
             * The method type of each is the same as
             * {@link PyMethodDescr#method}, which itself will be set to
             * "empty".
             */
            protected final MethodHandle[] methods;

            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr.General} that allows for multiple
             * accepted implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that
             *     method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            General(PyType objclass, ArgParser argParser,
                    List<MethodHandle> candidates) {
                super(objclass, argParser);
                this.methods = prepareCandidates(
                        MethodSignature.GENERAL, candidates);
            }

            @Override
            MethodHandle getHandle(Object self) {
                // Work out how to call this descriptor on that object
                int index = objclass.indexAccepted(self.getClass());
                try {
                    return methods[index];
                } catch (ArrayIndexOutOfBoundsException iobe) {
                    // This will behave as an empty slot
                    return method;
                }
            }

            @Override
            Object callMethod(Object self, Object[] args,
                    String[] names) throws TypeError, Throwable {
                /*
                 * The method handle type is {@code (O,O[])O}. The
                 * parser will make an array of the args, and where
                 * allowed, gather excess arguments into a tuple or
                 * dict, and fill missing ones from defaults.
                 */
                Object[] frame = argParser.parse(args, names);
                MethodHandle wrapped = getHandle(self);
                return wrapped.invokeExact(self, frame);
            }
        }

        /**
         * A variant of {@link PyMethodDescr.NoArgs} that allows for
         * multiple accepted implementations of {@code objclass}.
         */
        static class NoArgs extends PyMethodDescr.NoArgs {
            /**
             * Handles for the particular implementations of a method.
             * The method type of each is the same as
             * {@link PyMethodDescr#method}, which itself will be set to
             * "empty".
             */
            protected final MethodHandle[] methods;

            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr.General} that allows for multiple
             * accepted implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that
             *     method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            NoArgs(PyType objclass, ArgParser argParser,
                    List<MethodHandle> candidates) {
                super(objclass, argParser);
                this.methods = prepareCandidates(MethodSignature.NOARGS,
                        candidates);
            }

            @Override
            MethodHandle getHandle(Object self) {
                // Work out how to call this descriptor on that object
                int index = objclass.indexAccepted(self.getClass());
                try {
                    return methods[index];
                } catch (ArrayIndexOutOfBoundsException iobe) {
                    // This will behave as an empty slot
                    return method;
                }
            }

            @Override
            Object callMethod(Object self, Object[] args,
                    String[] names) throws TypeError, Throwable {
                // The method handle type is {@code (O)O}.
                checkNoArgs(args, names);
                MethodHandle wrapped = getHandle(self);
                return wrapped.invokeExact(self);
            }
        }

        /**
         * A variant of {@link PyMethodDescr.Positional} that allows for
         * multiple accepted implementations of {@code objclass}.
         */
        static class Positional extends PyMethodDescr.Positional {
            /**
             * Handles for the particular implementations of a method.
             * The method type of each is the same as
             * {@link PyMethodDescr#method}, which itself will be set to
             * "empty".
             */
            protected final MethodHandle[] methods;

            /**
             * Construct a method descriptor, a variant of
             * {@link PyMethodDescr.Positional} that allows for multiple
             * accepted implementations of {@code objclass}.
             *
             * @param objclass the class declaring the method
             * @param argParser describing the signature of the method
             * @param candidates handles to the implementations of that
             *     method
             */
            // Compare CPython PyDescr_NewMethod in descrobject.c
            Positional(PyType objclass, ArgParser argParser,
                    List<MethodHandle> candidates) {
                super(objclass, argParser);
                this.methods = prepareCandidates(
                        MethodSignature.POSITIONAL, candidates);
            }

            @Override
            MethodHandle getHandle(Object self) {
                // Work out how to call this descriptor on that object
                int index = objclass.indexAccepted(self.getClass());
                try {
                    return methods[index];
                } catch (ArrayIndexOutOfBoundsException iobe) {
                    // This will behave as an empty slot
                    return method;
                }
            }
        }
    }
}
