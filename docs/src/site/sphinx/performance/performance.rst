..  performance/performance.rst

Performance
###########

The Very Slow Jython Project is not directly a search for high performance.
The main question is whether an interpreter can be built correctly at all,
using the patterns we are exploring.
We have mostly avoided "speed-up tricks" in favour of clarity and generality,
so we could explore more territory.

However, the reason we explore the territory is that we think (thought)
we might find within it an implementation of Python that people will use.
For this, it has to be acceptably fast.
In fact, the strategic direction
(as opposed to tactical choices in any piece of code)
has been towards architecture that obtains high performance
through proper use of the dynamic language features of Java.
These features were not available to the original architects of Jython.

This question of whether we are using these features to best effect,
will be reflected in the execution time of individual operations.
Both the Python byte code interpreter
and Python compiled for the JVM
will string together the code for individual operations.
Micro-benchmarking is therefore the chosen approach.
The operations are:

..  toctree::
    :maxdepth: 1

    unary-operations
    binary-operations


This chapter collects together some micro-benchmarks on basic operations
in the different implementations being explored, in Jython 2.7.2,
and in the nearest equivalent Java (i.e. with known types) for comparison.
The code is in dedicated sub-projects ``vsj2bm`` and ``jy2bm``.
All the benchmarks are generated by JMH.
JMH takes care of "warm up",
meaning that all compilation and in-lining will have taken place
by the time measurements are done.

The measurements on VSJ 2 are predominantly of the abstract API
that supports the Python byte code interpreter.
If there were a compiler for VSJ 2,
it would probably emit calls to these methods.

Only relative timings will be significant.
In particular, we are interested how much overhead there is
relative to a similar operation expressed in Java.
The extra time is how much we pay for dynamic typing,
compared to where the type is known statically.

By calling the method repeatedly with the same types,
we induce Java to in-line the called methods, if it can,
and specialise them to the particular types in the test.
The cost of dynamic typing could then reduced (in the most successful cases)
to a test of an object's class
and a conditional branch not taken
to the slow path when not of the expected class.
For a binary operation, it would be two tests and two branches.

For those interested,
the test CPU is a lightly loaded AMD Athlon II X4 635 at 2.9GHz.
Java identifies as
``Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.6+8-LTS, mixed mode)``.

