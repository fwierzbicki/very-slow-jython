package uk.co.farowl.vsj1.example.treepython;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.junit.Test;

import uk.co.farowl.vsj1.TreePython.AbstractVisitor;
import uk.co.farowl.vsj1.TreePython.Node;
import uk.co.farowl.vsj1.TreePython.arg;
import uk.co.farowl.vsj1.TreePython.arguments;
import uk.co.farowl.vsj1.TreePython.expr;
import uk.co.farowl.vsj1.TreePython.expr_context;
import uk.co.farowl.vsj1.TreePython.keyword;
import uk.co.farowl.vsj1.TreePython.mod;
import uk.co.farowl.vsj1.TreePython.operator;
import uk.co.farowl.vsj1.TreePython.stmt;
import uk.co.farowl.vsj1.TreePython.unaryop;

/**
 * This test program exercises prototype code for generating code objects
 * from the AST after symbol tables have been built. These code objects
 * involve no actual bytecode: the code part is the AST, starting at the
 * appropriate node. The focus of the test is the other attributes (that
 * define the frame layout) and that these code objects get attached as
 * constants to the right part of the AST for execution.
 */
public class TestInterp2 {

    /**
     * Structure used to hold the reference correct result, generated by
     * <code>src/test/python/code_testgen.py</code>, by compiling examples
     * of nested code to their code objects. We compare to this the result
     * of supposedly equivalent reasoning performed locally in the test
     * program on the AST of the same Python source.
     */
    private static class RefCode {

        final String name;
        final int argcount;
        final int kwonlyargcount;
        final String[] names;
        final String[] varnames;
        final String[] freevars;
        final String[] cellvars;

        RefCode(int argcount, int kwonlyargcount, String[] names,
                String[] varnames, String[] freevars, String[] cellvars,
                String name) {
            this.argcount = argcount;
            this.kwonlyargcount = kwonlyargcount;
            this.name = name;
            this.names = names;
            this.varnames = varnames;
            this.freevars = freevars;
            this.cellvars = cellvars;
        }

        void check(PyCode c) {
            // System.out.printf(" *** Block %s ***\n", name);
            checkCounts(c);
            checkArrays(c);
        }

        void checkCounts(PyCode c) {
            assertEquals("argcount", argcount, c.argcount);
            assertEquals("kwonlyargcount", kwonlyargcount,
                    c.kwonlyargcount);
        }

        void checkArrays(PyCode c) {
            checkSortedArray("names", names, c.co_names);
            checkSortedArray("varnames", varnames, c.co_varnames,
                    argcount);
            checkSortedArray("cellvars", cellvars, c.co_cellvars);
            checkSortedArray("freevars", freevars, c.co_freevars);
        }

        /** Assert arrays are equal after sorting the contents of each. */
        private static void checkSortedArray(String message,
                String[] expected, String[] actual) {
            checkSortedArray(message, expected, actual, 0);
        }

        /**
         * Assert arrays are equal after sorting the contents of each from
         * the given element to the end.
         */
        private static void checkSortedArray(String message,
                String[] expected, String[] actual, int from) {
            // String fmt = "%s:\nref: %s\ntest:%s\n";
            // System.out.printf(fmt, message, Arrays.asList(expected),
            // Arrays.asList(actual));
            String[] e = sortedFrom(expected, from);
            String[] a = sortedFrom(actual, from);
            // System.out.printf(fmt, message, Arrays.asList(e),
            // Arrays.asList(a));
            assertArrayEquals(message, e, a);
        }

        /** Sort the tail of an array from the given element to the end. */
        private static <T> T[] sortedFrom(T[] array, int from) {
            T[] a = array.clone();
            if (from < a.length) {
                if (from <= 0) {
                    Arrays.sort(a);
                } else {
                    // Have to sort this in a copy.
                    T[] b = Arrays.copyOfRange(a, from, a.length);
                    Arrays.sort(b);
                    // Then put it back where it belongs
                    System.arraycopy(b, 0, a, from, b.length);
                }
            }
            return a;
        }

    }

    /**
     * Take the AST for a Python program with nested block scopes and
     * generate the code objects from it. Compare this with (selected
     * properties of) code objects dumped from a CPython compilation.
     *
     * @param module AST of program to compile
     * @param ref dump of code objects from CPython compilation
     */
    private void checkCode(mod module, RefCode[] ref) {

        // Compile the test AST
        PyCode code = compileAST(module, "<module>");

        // Collect generated code objects in a list
        final List<PyCode> codeList = new CodeList(code);

        // The supplied codeList tells us how many code objects
        final int N = ref.length;
        assertEquals("Number of code blocks", N, codeList.size());

        // We are poised to reel off the code objects we generated
        Iterator<PyCode> codeListIter = codeList.iterator();

        // Work through the reference result (hopefully in same order)
        for (RefCode refcode : ref) {
            PyCode c = codeListIter.next();
            refcode.check(c);
        }
    }

    /**
     * Helper class for <code>checkCode</code>, traversing the
     * <code>PyCode</code> tree.
     */
    private static class CodeList extends LinkedList<PyCode> {

        CodeList(PyCode c) {
            appendCodeObjects(c);
        }

        private void appendCodeObjects(PyCode c) {
            add(c);
            for (Object o : c.co_consts) {
                if (o != null && o instanceof PyCode) {
                    appendCodeObjects((PyCode)o);
                }
            }
        }
    }

    /** Our equivalent to the Python code object. */
    private static class PyCode {

        /**
         * This is our equivalent to bytecode that holds a sequence of
         * statements comprising the body of a function or module. Since
         * these are nodes in the AST, references to variables are
         * symbolic, and the symbol table must be present to map them into
         * frame locations. Literal constants are present in the AST nodes
         * that need them. Constants generated by compilation, in
         * particular, PyCode objects have to be associated through a map.
         */
        static class Code {

            /** Suite comprising the body of a function or module. */
            final List<stmt> body;
            /** Map names used in this scope to their meanings. */
            final SymbolTable symbolTable;
            /** Associate a node to a constant it requires. */
            final Map<Node, Object> constMap;

            Code(List<stmt> body, SymbolTable symbolTable,
                    Map<Node, Object> constMap) {
                this.body = body;
                this.symbolTable = symbolTable;
                this.constMap = constMap;
            }
        }

        /** Characteristics of a PyCode (as CPython co_flags). */
        enum Trait {
            VARARGS, VARKEYWORDS
        }

        final EnumSet<Trait> traits;

        /** Suite and symbols that are to us the executable code. */
        final Code code;

        /** Number of positional arguments (not counting varargs). */
        final int argcount;
        /** Number of keyword-only arguments (not counting varkeywords). */
        final int kwonlyargcount;
        /** Number of local variables. */
        final int nlocals;

        final Object[] co_consts;   // constant objects needed by the code

        // XXX: Not needed (?) but implement for test against CPython
        final String[] co_names;    // names referenced in the code
        final String[] co_varnames; // args and non-cell locals
        final String[] co_freevars; // names ref'd but not defined here
        final String[] co_cellvars; // names def'd here & ref'd elsewhere

        /** Construct from result of walking the AST. */
        public PyCode( //
                int argcount, // co_argcount
                int kwonlyargcount, // co_kwonlyargcount
                int nlocals, // co_nlocals

                Set<Trait> traits, // co_flags

                Code code, // co_code
                List<Object> consts, // co_consts

                Collection<String> names, // names ref'd in code
                Collection<String> varnames, // args and non-cell locals
                Collection<String> freevars, // names ref'd but not defined
                                             // here
                Collection<String> cellvars // names def'd here & ref'd
                                            // elsewhere
        ) {
            this.argcount = argcount;
            this.kwonlyargcount = kwonlyargcount;
            this.nlocals = nlocals;

            this.traits = EnumSet.copyOf(traits);
            this.code = code;

            this.co_consts = consts.toArray();

            this.co_names = names(names);
            this.co_varnames = names(varnames);
            this.co_freevars = names(freevars);
            this.co_cellvars = names(cellvars);
        }

        private static String[] names(Collection<String> c) {
            return c.toArray(new String[c.size()]);
        }
    }

    /**
     * Patterned after Python <code>symtable.SymbolTable</code>, this class
     * holds symbol (name) information for one scope and its lexically
     * contained scopes. This is also effectively a
     * <code>PySTEntryObject</code> from CPython <code>symtable.h</code>.
     * We have no need for a separately compiled <code>_symtable</code>
     * module and raw <code>_table</code> member.
     */
    private static abstract class SymbolTable {

        /** Scopes have a name (the name of the function, class, etc.. */
        final String name;
        /** The symbol table itself. */
        final Map<String, Symbol> symbols;
        /** Enclosing scope or null if and only if this is a module. */
        final SymbolTable parent;
        /** Enclosed scopes. */
        final List<SymbolTable> children;

        /**
         * Construct a scope with the given name and parent. This does not
         * enter the name in the parent symbol table: the caller should do
         * that.
         */
        SymbolTable(String name, SymbolTable parent) {
            this.symbols = new HashMap<>();
            this.parent = parent;
            this.name = name;
            this.children = new ArrayList<>();
        }

        /**
         * Expresses the final decision how the variable is accessed. Note
         * that being a function parameter is not a <code>ScopeType</code>:
         * parameters may be <code>LOCAL</code> or <code>CELL</code>.
         */
        enum ScopeType {
            /** A local name that is bound in this scope and not a cell. */
            LOCAL,
            /** A global name declared with <code>global</code>. */
            GLOBAL_EXPLICIT,
            /** A global name not declared with <code>global</code>. */
            GLOBAL_IMPLICIT,
            /** A non-local name not bound in this scope. */
            FREE,
            /** A non-local name bound in this scope. */
            CELL
        }

        /**
         * Make an entry for a name in the symbol table with the given
         * attribute flags, or add the flags to the existing entry.
         */
        Symbol add(String name, int flags) {
            Symbol s = symbols.get(name);
            if (s == null) {
                s = new Symbol(name, flags);
                symbols.put(name, s);
            } else {
                s.flags |= flags;
            }
            return s;
        }

        /**
         * Decide the location in storage of the variable named. We don't
         * do this until code generation.
         */
        void setIndex(String name, int index) {
            symbols.get(name).index = index;
        }

        /**
         * Enter all of these names (useful for global and nonlocal
         * declarations).
         */
        void addAll(Collection<String> names, int flags) {
            for (String name : names) {
                add(name, flags);
            }
        }

        /**
         * Make an entry for a child name space and add it to the symbol
         * table by name. (If an entry exists by this name already, augment
         * that entry with the name space.)
         */
        Symbol addChild(SymbolTable other) {
            Symbol s = symbols.get(other.name);
            if (s == null) {
                s = new Symbol(other);
                symbols.put(other.name, s);
            } else {
                s.addSpace(other);
                s.flags |= Symbol.ASSIGNED;
            }
            children.add(other);
            return s;
        }

        /**
         * Retrieve the named symbol from this table (or return null if not
         * found).
         */
        Symbol lookup(String name) {
            return symbols.get(name);
        }

        /**
         * The scope within which this is ultimately nested (or itself if a
         * module).
         */
        abstract ModuleSymbolTable getTop();

        /** <code>true</code> if scope is nested (not a module scope). */
        abstract boolean isNested();

        @Override
        public String toString() {
            String type = getClass().getSimpleName();
            return String.format("%s '%s'", type, name);
        }

        /** Return a list of names of symbols in this table. */
        Set<String> getIdentifiers() {
            return symbols.keySet();
        }

        /**
         * Given a name that is free in a scope <b>interior</b> to this
         * one, look in this scope's symbols for a matching name, and in
         * <b>enclosing</b> scopes until either a binding for the name has
         * been found, or it is proved it cannot be resolved. This free
         * name may have been declared explicitly <code>nonlocal</code> in
         * the original scope or it may just be used but not bound in the
         * original scope.
         *
         * The method returns true if and only if, in the scope where it is
         * found, the name is {@link ScopeType#LOCAL} or
         * {@link ScopeType#CELL}. A side effect of a successful search is
         * to convert the name to {@link ScopeType#CELL} in the scope where
         * it is found, and in all intervening scopes to
         * {@link ScopeType#FREE}. (In practice, the search will stop as
         * soon as the name is discovered <code>CELL</code> or
         * <code>FREE</code>, implying that a previous call has already
         * done the rest of our work.)
         */
        abstract boolean fixupFree(String name);

        /**
         * Resolve the symbols in this scope to their proper
         * {@link ScopeType}, also fixing-up parent scopes for those found
         * free in this scope. This method implements the "second pass"
         * over symbols in the compiler.
         */
        void resolveAllSymbols() {
            for (SymbolTable.Symbol s : symbols.values()) {
                // The use in this scope may resolve itself immediately
                if (!s.resolveScope()) {
                    // Not resolved: used free or is explicitly nonlocal
                    if (isNested() && parent.fixupFree(s.name)) {
                        // Appropriate referent exists in outer scopes
                        s.setScope(ScopeType.FREE);
                    } else if ((s.flags & Symbol.NONLOCAL) != 0) {
                        // No cell variable found: but declared non-local
                        throw new IllegalArgumentException(
                                "undefined non-local " + s.name);
                    } else {
                        // No cell variable found: assume global
                        s.setScope(ScopeType.GLOBAL_IMPLICIT);
                    }
                }
            }
        }

        /**
         * Apply {@link #resolveAllSymbols()} to the current scope and then
         * to child scopes recursively. Applied to a module, this completes
         * free variable fix-up for symbols used throughout the program.
         */
        protected void resolveSymbolsRecursively() {
            resolveAllSymbols();
            for (SymbolTable st : children) {
                st.resolveSymbolsRecursively();
            }
        }

        /**
         * Patterned after Python <code>symtable.Symbol</code>, this class
         * holds usage information for one symbol (name) in the scope
         * described by the symbol table where it is an entry.
         */
        static class Symbol {

            /** Declared global */
            private static final int GLOBAL = 1;
            /** Assigned in block scope */
            private static final int ASSIGNED = 2;
            /** Appears as formal parameter (function) */
            private static final int PARAMETER = 4;
            /** Declared non-local */
            private static final int NONLOCAL = 8;
            /** Used (referenced) in block scope */
            private static final int REFERENCED = 0x10;

            // Convenience for testing several kinds of "bound"
            private static final int BOUND = ASSIGNED | PARAMETER;

            /** Symbol name */
            final String name;
            /** Properties collected by scanning the AST for uses. */
            int flags;
            /** The final decision how the variable is accessed. */
            ScopeType scope = null;
            /** Index within a storage array in the executing frame. */
            int index = -1;

            /**
             * When the symbol represents a function or class, list the
             * name spaces of those scopes here. Note it is possible to
             * have several, and for the symbol to represent other types in
             * the same scope. null if and only if there are no such
             * associated namespaces.
             */
            private List<SymbolTable> namespaces;

            /**
             * Construct a symbol with given initial flags.
             */
            private Symbol(String name, int flags) {
                this.name = name;
                this.flags = flags;
                this.namespaces = Collections.emptyList();
            }

            /**
             * Construct a symbol representing one name space initially.
             */
            Symbol(SymbolTable other) {
                this.name = other.name;
                this.flags = ASSIGNED;
                this.namespaces = Collections.singletonList(other);
            }

            @Override
            public String toString() {
                return "<symbol " + name + ">";
            }

            void addSpace(SymbolTable other) {
                assert name == other.name;
                if (namespaces.isEmpty()) {
                    // First name space
                    namespaces = Collections.singletonList(other);
                } else {
                    if (namespaces.size() == 1) {
                        // Replace singleton list with a mutable one
                        SymbolTable existing = namespaces.get(0);
                        namespaces = new LinkedList<>();
                        namespaces.add(existing);
                    }
                    namespaces.add(other);
                }
            }

            void setScope(ScopeType scope) {
                this.scope = scope;
            }

            /**
             * If possible using local information only, resolve the scope
             * of the name, returning <code>true</code> if the result was
             * definitive. The result is not definitive, and the return is
             * <code>false</code>, when the name is free in this scope, or
             * is explicitly declared <code>nonlocal</code>. In either
             * case, the caller must search enclosing scopes for this name,
             * possibly adding the name free in them or converting the name
             * to {@link ScopeType#CELL} scope in the scope that binds the
             * name.
             *
             * @return false iff we must search enclosing scopes
             */
            boolean resolveScope() {
                if ((flags & GLOBAL) != 0) {
                    scope = ScopeType.GLOBAL_EXPLICIT;
                } else if ((flags & NONLOCAL) != 0) {
                    scope = ScopeType.LOCAL;
                    return false;
                } else if ((flags & BOUND) != 0) {
                    scope = ScopeType.LOCAL; // or CELL ultimately
                }
                return scope != null;
            }

            /**
             * Return <code>true</code> if the symbol is used in its scope.
             */
            boolean is_referenced() {
                return (flags & REFERENCED) != 0;
            }

            /**
             * Return <code>true</code> if the symbol is created from an
             * import statement.
             */
            public boolean is_imported() {
                // Imports not supported at the moment
                return false;
            }

            /** Return <code>true</code> if the symbol is a parameter. */
            boolean is_parameter() {
                return (flags & PARAMETER) != 0;
            }

            /** Return <code>true</code> if the symbol is global. */
            boolean is_global() {
                return scope == ScopeType.GLOBAL_IMPLICIT
                        || scope == ScopeType.GLOBAL_EXPLICIT;
            }

            /**
             * Return <code>true</code> if the symbol is declared global
             * with a global statement.
             */
            boolean is_declared_global() {
                return scope == ScopeType.GLOBAL_EXPLICIT;
            }

            /**
             * Return <code>true</code> if the symbol is local to its
             * scope.
             */
            boolean is_local() {
                return (flags & BOUND) != 0;
            }

            /**
             * Return <code>true</code> if the symbol is referenced in its
             * scope, but not assigned to.
             */
            boolean is_free() {
                return scope == ScopeType.FREE;
            }

            /**
             * Return <code>true</code> if the symbol is assigned to in its
             * scope.
             */
            boolean is_assigned() {
                return (flags & ASSIGNED) != 0;
            }

            /**
             * Returns true if name binding introduces new namespace.
             *
             * If the name is used as the target of a function or class
             * statement, this will be true.
             *
             * Note that a single name can be bound to multiple objects. If
             * boolean isNamespace() is true, the name may also be bound to
             * other objects, like an int or list, that does not introduce
             * a new namespace.
             */
            boolean is_namespace() {
                return !namespaces.isEmpty();
            }

            /** Return a list of namespaces bound to this name */
            List<SymbolTable> getNamespaces() {
                return namespaces;
            }

            /**
             * Returns the single namespace bound to this name.
             *
             * Raises ValueError if the name is bound to multiple
             * namespaces or none.
             */
            SymbolTable getNamespace() {
                if (namespaces.isEmpty()) {
                    throw new IllegalArgumentException(
                            "name is not bound a namespace");
                } else if (namespaces.size() == 1) {
                    return namespaces.get(0);
                } else {
                    throw new IllegalArgumentException(
                            "name is bound to multiple namespaces");
                }
            }
        }
    }

    /**
     * Symbol table representing the scope of a module, that is, the top
     * level of the scope tree.
     */
    private static class ModuleSymbolTable extends SymbolTable {

        private String filename;

        ModuleSymbolTable(mod module, String filename) {
            super("top", null);
            this.filename = filename;
        }

        @Override
        ModuleSymbolTable getTop() {
            return this;
        }

        @Override
        boolean isNested() {
            return false;
        }

        @Override
        boolean fixupFree(String name) {
            // The top cannot be the referent of a non-local name.
            return false;
        }
    }

    /**
     * Symbol table representing the scope of a function body, which cannot
     * therefore be the top level of the scope tree.
     */
    private static class FunctionSymbolTable extends SymbolTable {

        private final ModuleSymbolTable top;
        /**
         * The parameters in order, with <code>*args</code> and
         * <code>**kwargs</code> last, filled when visiting the definition.
         */
        final List<Symbol> parameters;
        /** Function has a <code>*args</code> positional receiver */
        final boolean varargs;
        /** Function has a <code>*kwrgs</code> dictionary receiver */
        final boolean varkeywords;

        /**
         * Create nested symbol table from a function declaration in a
         * scope that becomes a parent of this table.
         *
         * @param def the function definition
         * @param parent enclosing scope must be non-null
         */
        FunctionSymbolTable(stmt.FunctionDef def, SymbolTable parent) {
            super(def.name, parent);
            this.varargs = def.args.vararg != null;
            this.varkeywords = def.args.kwarg != null;
            this.top = parent.getTop();
            this.parameters = new LinkedList<>();
        }

        @Override
        Symbol add(String name, int flags) {
            Symbol s = super.add(name, flags);
            if ((flags & SymbolTable.Symbol.PARAMETER) != 0) {
                // s is being declared as a parameter
                parameters.add(s);
            }
            return s;
        }

        @Override
        ModuleSymbolTable getTop() {
            return top;
        }

        @Override
        boolean isNested() {
            return true;
        }

        /** Collect the symbols for which the predicate is true. */
        protected List<Symbol> symbolsMatching(Predicate<Symbol> test) {
            return symbols.values().stream().filter(test)
                    .collect(Collectors.toList());
        }

        /**
         * Return a list containing names of parameters to this function.
         */
        List<Symbol> getParameters() {
            return parameters;
        }

        /** Return a list containing names of locals in this function. */
        List<Symbol> getLocals() {
            return symbolsMatching(Symbol::is_local);
        }

        /** Return a list containing names of globals in this function. */
        List<Symbol> getGlobals() {
            return symbolsMatching(Symbol::is_global);
        }

        /**
         * Return a list containing names of free variables in this
         * function.
         */
        List<Symbol> getFrees() {
            return symbolsMatching(Symbol::is_free);
        }

        @Override
        boolean fixupFree(String name) {
            // Look up in this scope
            SymbolTable.Symbol s = symbols.get(name);
            if (s != null) {
                /*
                 * Found name in this scope: but only CELL, FREE or LOCAL
                 * are allowable.
                 */
                switch (s.scope) {
                    case CELL:
                    case FREE:
                        // Name is CELL here or in an enclosing scope
                        return true;
                    case LOCAL:
                        // Bound here, make it CELL in this scope
                        s.setScope(ScopeType.CELL);
                        return true;
                    default:
                        /*
                         * Any other scope value is not compatible with the
                         * alleged non-local nature of this name in the
                         * original scope.
                         */
                        return false;
                }
            } else {
                /*
                 * The name is not present in this scope. If it can be
                 * found in some enclosing scope then we will add it FREE
                 * here.
                 */
                if (parent.fixupFree(name)) {
                    s = add(name, 0);
                    s.setScope(ScopeType.FREE);
                    return true;
                } else {
                    return false;
                }
            }
        }
    }

    /**
     * Visitor on the AST adding compile-time information to each node
     * about the binding of names. In this version, the information is
     * added externally through a Map created in construction and filled
     * during the traverse.
     */
    private static class SymbolVisitor extends AbstractVisitor<Void> {

        final String filename;

        /** Description of the current scope (symbol table). */
        protected SymbolTable current;
        /** Map from nodes that are block scopes to their symbols. */
        final Map<Node, SymbolTable> scopeMap;
        /** Parameter names from the function definition (heading). */
        private ArrayList<String> parameterNames = new ArrayList<>();

        /**
         * Construct a SymbolVisitor to traverse an AST and fill in
         * information about each block scope.
         */
        SymbolVisitor(mod module, String filename) {
            this.filename = filename;
            this.scopeMap = new HashMap<>();
        }

        /**
         * Get the generated map from nodes to the name-binding information
         * generated by visiting the tree. Only nodes that represent block
         * scopes (Module and FunctionDef) will be keys in this map.
         */
        public Map<Node, SymbolTable> getBlockMap() {
            return scopeMap;
        }

        /**
         * The visitor is normally applied to a module.
         */
        @Override
        public Void visit_Module(mod.Module module) {
            // Create a symbol table for the scope
            current = new ModuleSymbolTable(module, filename);
            scopeMap.put(module, current);
            try {
                // Process the statements in the block
                return super.visit_Module(module);
            } finally {
                // Restore context (should be null!)
                current = current.parent;
            }
        }

        @Override
        public Void visit_FunctionDef(stmt.FunctionDef functionDef) {
            // Visit the argument list in the current scope
            parameterNames.clear();
            functionDef.args.accept(this);
            visitAll(functionDef.decorator_list);
            visitIfNotNull(functionDef.returns);

            // Now start a nested scope as a child of the current one
            FunctionSymbolTable child =
                    new FunctionSymbolTable(functionDef, current);
            current.addChild(child);

            // Add a correspondence between this node and the child scope
            scopeMap.put(functionDef, child);

            // Make the child scope current
            current = child;

            // Add the parameter names as the first symbols
            current.addAll(parameterNames, SymbolTable.Symbol.PARAMETER);

            // Visit the body of the function in the new scope
            visitAll(functionDef.body);

            // Restore context
            current = current.parent;
            return null;
        }

        @Override
        public Void visit_Global(stmt.Global global) {
            current.addAll(global.names, SymbolTable.Symbol.GLOBAL);
            // Explicit global declaration counts for the top level too.
            if (current.isNested()) {
                current.getTop().addAll(global.names,
                        SymbolTable.Symbol.GLOBAL);
            }
            return null;
        }

        @Override
        public Void visit_Nonlocal(stmt.Nonlocal nonlocal) {
            current.addAll(nonlocal.names, SymbolTable.Symbol.NONLOCAL);
            return null;
        }

        @Override
        public Void visit_Name(expr.Name name) {
            if (name.ctx == Load) {
                current.add(name.id, SymbolTable.Symbol.REFERENCED);
            } else {
                current.add(name.id, SymbolTable.Symbol.ASSIGNED);
            }
            return null;
        }

        @Override
        public Void visit_arguments(arguments _arguments) {
            // Constructor order is:
            visitAll(_arguments.args);
            visitIfNotNull(_arguments.vararg);
            visitAll(_arguments.kwonlyargs);
            visitIfNotNull(_arguments.kwarg);
            visitAll(_arguments.defaults);
            visitAll(_arguments.kw_defaults);
            return null;
        }

        @Override
        public Void visit_arg(arg arg) {// aaaargh!!!
            // Save the name (it belongs to the future nested scope)
            parameterNames.add(arg.arg);
            return null;
        }

        @Override
        public Void visit_keyword(keyword keyword) {
            // Save the name (it belongs to the future nested scope)
            parameterNames.add(keyword.arg);
            return keyword.value.accept(this);
        }
    }

    /**
     * Compile the module AST and return its code object. No actual
     * compilation is performed (since we aim to interpret the AST), but we
     * return a <code>PyCode</code> object. The returned module (code
     * object) will contain in its constants the code objects of functions
     * declared at module level, and so on recursively down the structure.
     * In our present implementation, code objects also contain a reference
     * to the AST node to which they correspond (since this, not byte code,
     * is to be interpreted when they are executed), and the symbol table
     * generated from it.
     */
    private static PyCode compileAST(mod module, String filename) {

        // Build symbol table from the module AST
        SymbolVisitor visitor = new SymbolVisitor(module, filename);
        module.accept(visitor);
        final Map<Node, SymbolTable> scopeMap = visitor.getBlockMap();

        // Complete scope deductions for AST in each SymbolTable
        scopeMap.get(module).resolveSymbolsRecursively();

        // Walk the AST to create code objects at appropriate nodes
        CodeGenerator codeGenerator = new CodeGenerator(scopeMap);
        module.accept(codeGenerator);
        return codeGenerator.getPyCode();
    }

    /**
     * Visitor on the AST adding code objects using the symbol data
     * attached to each block scope in a previous pass. Each instance of
     * <code>CodeGenerator</code> produces one <code>PyCode</code> object,
     * representing the starting node (which must be a module), and makes
     * an entry for it in the map passed in at construction time.
     * <p>
     * Each time a <code>CodeGenerator</code> encounters a function
     * definition, it launches another <code>CodeGenerator</code> to
     * analyse it and add it to the same map, and so on recursively down
     * the program structure. The <code>PyCode</code> it generates must be
     * accessed by calling {@link #getPyCode()}, and all the
     * <code>PyCode</code> objects generated by nested invocation appear
     * within this structure as constants.
     */
    private static class CodeGenerator extends AbstractVisitor<Void> {

        /**
         * Holds a mapping from a function definition or module node to the
         * symbol table of its block.
         */
        private final Map<Node, SymbolTable> scopeMap;

        /** Suite comprising the body of a function or module. */
        List<stmt> body;

        /** Map names used in this scope to their meanings. */
        SymbolTable symbolTable;

        /**
         * Holds a mapping from a function definition or module node to the
         * code object representing its body. MOre generally, maps any node
         * to a constant it needs.
         */
        private final Map<Node, Object> constMap = new HashMap<>();

        /** Characteristics of the code block (CPython co_flags). */
        Set<PyCode.Trait> traits = EnumSet.noneOf(PyCode.Trait.class);

        /** Number of positional arguments. */
        int argcount = 0;
        /** Number of keyword-only arguments. */
        int kwonlyargcount = 0;

        /** Values appearing as constants in the code. */
        List<Object> consts = new LinkedList<>();

        /** Names used to reference global and built-in objects. */
        List<String> names = new LinkedList<>();
        /** Parameter names followed by non-cell local variables. */
        List<String> varnames = new LinkedList<>();
        /** Names bound in this scope but referenced free elsewhere. */
        List<String> cellvars = new LinkedList<>();
        /** Names free in this scope. */
        List<String> freevars = new LinkedList<>();

        /**
         * Construct a CodeGenerator to traverse an AST and provide each
         * body with a code object.
         *
         * @param scopeMap from nodes to their symbol tables
         */
        CodeGenerator(Map<Node, SymbolTable> scopeMap) {
            this.scopeMap = scopeMap;
        }

        /**
         * Create a <code>PyCode</code> from the information gathered by
         * this visitor.
         */
        PyCode getPyCode() {
            PyCode.Code raw = new PyCode.Code(body, symbolTable, constMap);
            PyCode code = new PyCode( //
                    argcount, kwonlyargcount, varnames.size(), // sizes
                    traits, // co_flags
                    raw, // co_code
                    consts, // co_consta
                    names, varnames, freevars, cellvars // co_* names
            );
            return code;
        }

        private static String[] names(Collection<String> c) {
            return c.toArray(new String[c.size()]);
        }

        /**
         * Assign a location in the frame to each symbol. Parameters (if
         * this is a function) have already been assigned in visiting
         * function definition.
         *
         * @param table for the current block
         */
        private void finishLayout() {
            // Iterate symbols (in insertion order)
            for (SymbolTable.Symbol s : symbolTable.symbols.values()) {
                switch (s.scope) {
                    case CELL:
                        addSymbol(s, cellvars);
                        break;
                    case FREE:
                        addSymbol(s, freevars);
                        break;
                    case GLOBAL_EXPLICIT:
                    case GLOBAL_IMPLICIT:
                        if (s.is_assigned() || s.is_referenced()) {
                            addSymbol(s, names);
                        }
                        break;
                    case LOCAL:
                        // Parameters were already added in the walk
                        if (!s.is_parameter()) {
                            if (symbolTable.isNested()) {
                                addSymbol(s, varnames);
                            } else {
                                addSymbol(s, names);
                            }
                        }
                        break;
                }
            }
        }

        /**
         * Lay out one variable in the given section of the (implied)
         * frame, and record its position in the symbol table.
         *
         * @param s symbol; table entry for the variable
         * @param c collection to which it is added
         */
        private static void addSymbol(SymbolTable.Symbol s,
                Collection<String> c) {
            s.index = c.size();
            c.add(s.name);
        }

        /**
         * Add an object to the constants section of the code object.
         *
         * @param value to add
         * @return index of this constant in this.consts
         */
        private int addConst(Object value) {
            int pos = consts.size();
            consts.add(value);
            return pos;
        }

        @Override
        public Void visit_Module(mod.Module module) {
            // Process the associated block scope from the symbol table
            symbolTable = scopeMap.get(module);
            body = module.body;

            // Walk the child nodes: some define functions
            super.visit_Module(module);

            // Fill the rest of the frame layout from the symbol table
            finishLayout();

            // The code currently generated is the code for this node
            constMap.put(module, getPyCode());
            return null;
        }

        @Override
        public Void visit_FunctionDef(stmt.FunctionDef functionDef) {
            // This has to have two behaviours
            if (symbolTable != null) {
                /*
                 * We arrived here while walking the body of some block.
                 * Start a nested code generator for the function being
                 * defined.
                 */
                CodeGenerator codeGenerator = new CodeGenerator(scopeMap);
                functionDef.accept(codeGenerator);
                // The code object generated is the code for this node
                PyCode code = codeGenerator.getPyCode();
                constMap.put(functionDef, code);
                addConst(code);

            } else {
                /*
                 * We are a nested code generator that just began this
                 * node. The work we do is in the nested scope.
                 */
                symbolTable = scopeMap.get(functionDef);
                body = functionDef.body;
                // Visit the parameters, assigning frame locations
                functionDef.args.accept(this);

                // Don't care about decorators (?)
                // visitAll(functionDef.decorator_list);
                // visitIfNotNull(functionDef.returns);

                /*
                 * Walk the child nodes assigning frame locations to names.
                 * Some statements will define further functions
                 */
                visitAll(functionDef.body);

                // Fill the rest of the frame layout from the symbol table
                finishLayout();
            }
            return null;
        }

        @Override
        public Void visit_arguments(arguments parameters) {
            // Order of visiting determines storage layout
            // args, kwarg, vararg, kwonlyargs
            visitAll(parameters.args);
            argcount = varnames.size();
            visitAll(parameters.kwonlyargs);
            kwonlyargcount = varnames.size() - argcount;
            // Optionally, there's a *args
            if (parameters.vararg != null) {
                // Function accepts arguments as a tuple
                traits.add(PyCode.Trait.VARARGS);
                parameters.vararg.accept(this);
            }
            // Optionally, there's a **kwargs
            if (parameters.kwarg != null) {
                // Function accepts arguments as a keyword dictionary
                traits.add(PyCode.Trait.VARKEYWORDS);
                parameters.kwarg.accept(this);
            }
            // No code to generate for these?
            // visitAll(parameters.defaults);
            // visitAll(parameters.kw_defaults);
            return null;
        }

        @Override
        public Void visit_arg(arg arg) {
            // Allocate this parameter a space in the frame
            addSymbol(symbolTable.lookup(arg.arg), varnames);
            return null;
        }

        @Override
        public Void visit_keyword(keyword keyword) {
            // Allocate this parameter a space in the frame
            addSymbol(symbolTable.lookup(keyword.arg), varnames);
            return null;
        }
    }

    // ------------------------------------------------------------------
    // Literal AST: helper methods
    // ------------------------------------------------------------------

    /**
     * Helper method for the literal AST: create a list from a sequence of
     * arguments.
     *
     * @see #cast(List, Class)
     * @param values array of any object
     * @return list of the same
     */
    private static List<?> list(Object... values) {
        return Arrays.asList(values);
    }

    /**
     * Safely convert a list of objects to a list of a particular element
     * class. This is a helper function for building the AST from literal
     * functions. Wherever a list is provided in the the AST, it will have
     * compile-time type of only <code>List&lt;?&gt;</code>. However, the
     * grammar guarantees it a list of a particular type, according to
     * context. This method builds a list of the required type.
     *
     * @param values the elements, all instances of elementClass.
     * @param elementClass the actual type of the values.
     * @return a copy of the list with given element-type, statically.
     */
    private static <T> List<T> cast(List<?> values,
            Class<T> elementClass) {
        List<T> list = new ArrayList<>(values.size());
        for (Object v : values) {
            list.add(elementClass.cast(v));
        }
        return list;
    }

    // @formatter:off

    private static final operator Add = operator.Add;
    private static final operator Sub = operator.Sub;
    private static final operator Mult = operator.Mult;
    private static final operator Div = operator.Div;
    private static final unaryop UAdd = unaryop.UAdd;
    private static final unaryop USub = unaryop.USub;
    private static final expr_context Load = expr_context.Load;
    private static final expr_context Store = expr_context.Store;

    private static mod Module(List<?> body)
        { return new mod.Module(cast(body, stmt.class)); }

    private static stmt FunctionDef(String name, arguments args,
            List<?> body, List<?> decorator_list, expr returns) {
        return new stmt.FunctionDef(name, args, cast(body, stmt.class),
                cast(decorator_list, expr.class), returns);}
    private static stmt Return(expr value)
        { return new stmt.Return(value); }
    private static stmt Delete(List<?> targets)
        { return new stmt.Delete(cast(targets, expr.class)); }
    private static stmt Assign(List<?> targets, expr value)
        { return new stmt.Assign(cast(targets, expr.class), value); }
    private static stmt Global(List<?> names)
        { return new stmt.Global(cast(names, String.class)); }
    private static stmt Nonlocal(List<?> names)
        { return new stmt.Nonlocal(cast(names, String.class)); }
    private static stmt Expr(expr value)
        { return new stmt.Expr(value); }

    private static expr BinOp(expr left, operator op, expr right)
        { return new expr.BinOp(left, op, right); }
    private static expr UnaryOp(unaryop op, expr operand)
        { return new expr.UnaryOp(op, operand); }
    private static expr Call(expr func, List<?> args, List<?> keywords){
        return new expr.Call(func, cast(args, expr.class),
                cast(keywords, keyword.class)); }
    private static expr Num(Object n)
        { return new expr.Num(n); }
    private static expr Str(String s)
        { return new expr.Str(s); }
    private static expr Name(String id, expr_context ctx)
        { return new expr.Name(id, ctx); }

    private static arguments arguments(List<?> args, arg vararg,
            List<?> kwonlyargs, List<?> kw_defaults, arg kwarg,
            List<?> defaults) {
        return new arguments(cast(args, arg.class), vararg,
                cast(kwonlyargs, arg.class), cast(kw_defaults, expr.class),
                kwarg, cast(defaults, expr.class));
        }

    private static arg arg(String arg, expr annotation)
        { return new arg(arg, annotation); }

    private static keyword keyword(String arg, expr value)
        { return new keyword(arg, value); }

    // @formatter:on

    // ======= Generated examples ==========


 // globprog1

     @Test public void globprog1() {
         // @formatter:off
         // # Test allocation of "names" (globals)
         // # global d is *not* ref'd at module level
         // b = 1
         // a = 6
         // result = 0
         //
         // def p():
         //     global result
         //     def q():
         //         global d # not ref'd at module level
         //         d = a + b
         //     q()
         //     result = a * d
         //
         // p()
         mod module = Module(
     list(
         Assign(list(Name("b", Store)), Num(1)),
         Assign(list(Name("a", Store)), Num(6)),
         Assign(list(Name("result", Store)), Num(0)),
         FunctionDef(
             "p",
             arguments(list(), null, list(), list(), null, list()),
             list(
                 Global(list("result")),
                 FunctionDef(
                     "q",
                     arguments(list(), null, list(), list(), null, list()),
                     list(
                         Global(list("d")),
                         Assign(list(Name("d", Store)), BinOp(Name("a", Load), Add, Name("b", Load)))),
                     list(),
                     null),
                 Expr(Call(Name("q", Load), list(), list())),
                 Assign(list(Name("result", Store)), BinOp(Name("a", Load), Mult, Name("d", Load)))),
             list(),
             null),
         Expr(Call(Name("p", Load), list(), list()))))
         ;
         // @formatter:on

 checkCode(module, new RefCode[]{ // globprog1
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"b","a","result","p"}, // co_names,
         new String[]{}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "<module>" ),
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"a","d","result"}, // co_names,
         new String[]{"q"}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "p" ),
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"a","b","d"}, // co_names,
         new String[]{}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "q" ),
 });
 }


 // globprog2

     @Test public void globprog2() {
         // @formatter:off
         // # Test allocation of "names" (globals)
         // # global d is *assigned* at module level
         // b = 1
         // a = 6
         // result = 0
         //
         // def p():
         //     global result
         //     def q():
         //         global d
         //         d = a + b
         //     q()
         //     result = a * d
         //
         // d = 41
         // p()
         mod module = Module(
     list(
         Assign(list(Name("b", Store)), Num(1)),
         Assign(list(Name("a", Store)), Num(6)),
         Assign(list(Name("result", Store)), Num(0)),
         FunctionDef(
             "p",
             arguments(list(), null, list(), list(), null, list()),
             list(
                 Global(list("result")),
                 FunctionDef(
                     "q",
                     arguments(list(), null, list(), list(), null, list()),
                     list(
                         Global(list("d")),
                         Assign(list(Name("d", Store)), BinOp(Name("a", Load), Add, Name("b", Load)))),
                     list(),
                     null),
                 Expr(Call(Name("q", Load), list(), list())),
                 Assign(list(Name("result", Store)), BinOp(Name("a", Load), Mult, Name("d", Load)))),
             list(),
             null),
         Assign(list(Name("d", Store)), Num(41)),
         Expr(Call(Name("p", Load), list(), list()))))
         ;
         // @formatter:on

 checkCode(module, new RefCode[]{ // globprog2
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"b","a","result","p","d"}, // co_names,
         new String[]{}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "<module>" ),
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"a","d","result"}, // co_names,
         new String[]{"q"}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "p" ),
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"a","b","d"}, // co_names,
         new String[]{}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "q" ),
 });
 }


 // globprog3

     @Test public void globprog3() {
         // @formatter:off
         // # Test allocation of "names" (globals)
         // # global d *decalred* but not used at module level
         // global a, b, d
         // b = 1
         // a = 6
         // result = 0
         //
         // def p():
         //     global result
         //     def q():
         //         global d
         //         d = a + b
         //     q()
         //     result = a * d
         //
         // p()
         mod module = Module(
     list(
         Global(list("a", "b", "d")),
         Assign(list(Name("b", Store)), Num(1)),
         Assign(list(Name("a", Store)), Num(6)),
         Assign(list(Name("result", Store)), Num(0)),
         FunctionDef(
             "p",
             arguments(list(), null, list(), list(), null, list()),
             list(
                 Global(list("result")),
                 FunctionDef(
                     "q",
                     arguments(list(), null, list(), list(), null, list()),
                     list(
                         Global(list("d")),
                         Assign(list(Name("d", Store)), BinOp(Name("a", Load), Add, Name("b", Load)))),
                     list(),
                     null),
                 Expr(Call(Name("q", Load), list(), list())),
                 Assign(list(Name("result", Store)), BinOp(Name("a", Load), Mult, Name("d", Load)))),
             list(),
             null),
         Expr(Call(Name("p", Load), list(), list()))))
         ;
         // @formatter:on

 checkCode(module, new RefCode[]{ // globprog3
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"b","a","result","p"}, // co_names,
         new String[]{}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "<module>" ),
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"a","d","result"}, // co_names,
         new String[]{"q"}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "p" ),
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"a","b","d"}, // co_names,
         new String[]{}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "q" ),
 });
 }


 // builtin

     @Test public void builtin() {
         // @formatter:off
         // # Test allocation of "names" (globals and a built-in)
         // a = -6
         // b = 7
         // result = min(0, b)
         //
         // def p():
         //     global result
         //     def q():
         //         global a
         //         a = abs(a)
         //     q()
         //     result = a * b
         //
         // p()
         mod module = Module(
     list(
         Assign(list(Name("a", Store)), UnaryOp(USub, Num(6))),
         Assign(list(Name("b", Store)), Num(7)),
         Assign(list(Name("result", Store)), Call(Name("min", Load), list(Num(0), Name("b", Load)), list())),
         FunctionDef(
             "p",
             arguments(list(), null, list(), list(), null, list()),
             list(
                 Global(list("result")),
                 FunctionDef(
                     "q",
                     arguments(list(), null, list(), list(), null, list()),
                     list(
                         Global(list("a")),
                         Assign(list(Name("a", Store)), Call(Name("abs", Load), list(Name("a", Load)), list()))),
                     list(),
                     null),
                 Expr(Call(Name("q", Load), list(), list())),
                 Assign(list(Name("result", Store)), BinOp(Name("a", Load), Mult, Name("b", Load)))),
             list(),
             null),
         Expr(Call(Name("p", Load), list(), list()))))
         ;
         // @formatter:on

 checkCode(module, new RefCode[]{ // builtin
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"a","b","min","result","p"}, // co_names,
         new String[]{}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "<module>" ),
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"a","b","result"}, // co_names,
         new String[]{"q"}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "p" ),
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"abs","a"}, // co_names,
         new String[]{}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "q" ),
 });
 }


 // argprog1

     @Test public void argprog1() {
         // @formatter:off
         // # Test allocation of argument lists and locals
         // def p(eins, zwei):
         //     def sum(un, deux, trois):
         //         return un + deux + trois
         //     def diff(tolv, fem):
         //         return tolv - fem
         //     def prod(sex, sju):
         //         return sex * sju
         //     drei = 3
         //     six = sum(eins, zwei, drei)
         //     seven = diff(2*six, drei+zwei)
         //     return prod(six, seven)
         //
         // result = p(1, 2)
         mod module = Module(
     list(
         FunctionDef(
             "p",
             arguments(list(arg("eins", null), arg("zwei", null)), null, list(), list(), null, list()),
             list(
                 FunctionDef(
                     "sum",
                     arguments(
                         list(arg("un", null), arg("deux", null), arg("trois", null)),
                         null,
                         list(),
                         list(),
                         null,
                         list()),
                     list(Return(BinOp(BinOp(Name("un", Load), Add, Name("deux", Load)), Add, Name("trois", Load)))),
                     list(),
                     null),
                 FunctionDef(
                     "diff",
                     arguments(list(arg("tolv", null), arg("fem", null)), null, list(), list(), null, list()),
                     list(Return(BinOp(Name("tolv", Load), Sub, Name("fem", Load)))),
                     list(),
                     null),
                 FunctionDef(
                     "prod",
                     arguments(list(arg("sex", null), arg("sju", null)), null, list(), list(), null, list()),
                     list(Return(BinOp(Name("sex", Load), Mult, Name("sju", Load)))),
                     list(),
                     null),
                 Assign(list(Name("drei", Store)), Num(3)),
                 Assign(
                     list(Name("six", Store)),
                     Call(
                         Name("sum", Load),
                         list(Name("eins", Load), Name("zwei", Load), Name("drei", Load)),
                         list())),
                 Assign(
                     list(Name("seven", Store)),
                     Call(
                         Name("diff", Load),
                         list(
                             BinOp(Num(2), Mult, Name("six", Load)),
                             BinOp(Name("drei", Load), Add, Name("zwei", Load))),
                         list())),
                 Return(Call(Name("prod", Load), list(Name("six", Load), Name("seven", Load)), list()))),
             list(),
             null),
         Assign(list(Name("result", Store)), Call(Name("p", Load), list(Num(1), Num(2)), list()))))
         ;
         // @formatter:on

 checkCode(module, new RefCode[]{ // argprog1
     new RefCode( //
         0, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{"p","result"}, // co_names,
         new String[]{}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "<module>" ),
     new RefCode( //
         2, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{}, // co_names,
         new String[]{"eins","zwei","sum","diff","prod","drei","six","seven"}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "p" ),
     new RefCode( //
         3, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{}, // co_names,
         new String[]{"un","deux","trois"}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "sum" ),
     new RefCode( //
         2, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{}, // co_names,
         new String[]{"tolv","fem"}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "diff" ),
     new RefCode( //
         2, // co_argcount,
         0, // co_kwonlyargcount
         new String[]{}, // co_names,
         new String[]{"sex","sju"}, // co_varnames,
         new String[]{}, // co_cellvars,
         new String[]{}, // co_freevars
         "prod" ),
 });
 }



    // ======= End of generated examples ==========
}
