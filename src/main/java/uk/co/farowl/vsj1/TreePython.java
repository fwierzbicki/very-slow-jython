package uk.co.farowl.vsj1;
// Generated by Compile
// Generated from ~\local\asdl\TreePython.asdl
//

/**
 * Outer class scoping the types defined in the ASDL
 * file:   <code>~\local\\asdl\TreePython.asdl</code>,
 * module: <code>TreePython</code>.
 */
public abstract class TreePython {

    /**
     * All definitions in this module implement this interface to
     * support a generic approach to walking the tree.
     */
    public interface Node {
        /**
         * Allows a <code>Visitor</code> to visit this <code>Node</code>
         * without knowing its exact type. The <code>Node</code> dispatches
         * to the appropriate type-specific method of the visitor.
         */
        <T> T accept(Visitor<T> visitor);
    }

    public static abstract class mod extends ExecNode implements Node {

        public static class Module extends mod {
            public java.util.List<stmt> body;
            public Module(java.util.List<stmt> body){
                this.body = body;
            }

            @Override
            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Module(this);
            }
        }

    }

    public static abstract class stmt extends ExecNode implements Node {

        public static class Delete extends stmt {
            public java.util.List<expr> targets;
            public Delete(java.util.List<expr> targets){
                this.targets = targets;
            }

            @Override
            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Delete(this);
            }
        }

        public static class Assign extends stmt {
            public java.util.List<expr> targets;
            public expr value;
            public Assign(java.util.List<expr> targets, expr value){
                this.targets = targets;
                this.value = value;
            }

            @Override
            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Assign(this);
            }
        }

        public static class Global extends stmt {
            public java.util.List<String> names;
            public Global(java.util.List<String> names){
                this.names = names;
            }

            @Override
            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Global(this);
            }
        }

        public static class Nonlocal extends stmt {
            public java.util.List<String> names;
            public Nonlocal(java.util.List<String> names){
                this.names = names;
            }

            @Override
            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Nonlocal(this);
            }
        }

    }

    public static abstract class expr extends ExecNode implements Node {

        public static class BinOp extends expr {
            public expr left;
            public operator op;
            public expr right;
            public BinOp(expr left, operator op, expr right){
                this.left = left;
                this.op = op;
                this.right = right;
            }

            @Override
            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_BinOp(this);
            }
        }

        public static class UnaryOp extends expr {
            public unaryop op;
            public expr operand;
            public UnaryOp(unaryop op, expr operand){
                this.op = op;
                this.operand = operand;
            }

            @Override
            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_UnaryOp(this);
            }
        }

        public static class Num extends expr {
            public Object n;
            public Num(Object n){
                this.n = n;
            }

            @Override
            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Num(this);
            }
        }

        public static class Name extends expr {
            public String id;
            public expr_context ctx;
            public Name(String id, expr_context ctx){
                this.id = id;
                this.ctx = ctx;
            }

            @Override
            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Name(this);
            }
        }

    }

    public enum operator {Add, Sub, Mult, Div}

    public enum unaryop {UAdd, USub}

    public enum expr_context {Load, Store, Del}


    public interface Visitor<T> {
        default T visit_Module(mod.Module _Module){ return null; }
        default T visit_Delete(stmt.Delete _Delete){ return null; }
        default T visit_Assign(stmt.Assign _Assign){ return null; }
        default T visit_Global(stmt.Global _Global){ return null; }
        default T visit_Nonlocal(stmt.Nonlocal _Nonlocal){ return null; }
        default T visit_BinOp(expr.BinOp _BinOp){ return null; }
        default T visit_UnaryOp(expr.UnaryOp _UnaryOp){ return null; }
        default T visit_Num(expr.Num _Num){ return null; }
        default T visit_Name(expr.Name _Name){ return null; }

    }
}
