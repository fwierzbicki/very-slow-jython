/*
 * Templates for the generation of Java source from ASDL.
 * This differs from the standard in that:
 * 1. Methods in interface Visitor provide a default implementation
 *    returning null.
 * 2. Nodes all extend uk.co.farowl.vsj1.ExecNode.
 */

param ::= [
    "javaNode" : "ExecNode"
]

// Java type to use in place of ASDL type (single id)
asdlTypeToJava ::= [
    "identifier" : "String",
    "string" : "String",
    "object" : "Object",
    "constant" : "Object",
    default: key
]

// Java type to use in place of ASDL type (optional or sequence)
asdlTypeToJavaObjectType ::= [
    "identifier" : "String",
    "int" : "Integer",
    "string" : "String",
    "object" : "Object",
    "constant" : "Object",
    default: key
]

// Emit an Abstract Syntax Definition source file for the module
main(command, asdlCodeRoot, asdlPackagePath) ::= <<
// Generated by <command.tool> from
// <command.file>
// using template "<command.template>" in group file
// <command.groupfile>
//
<if(asdlPackagePath)>package <asdlPackagePath;separator=".">;<endif>

/**
 * Outer class scoping the types defined in the ASDL module
 * \<code><asdlCodeRoot.name>\</code>.
 */
public abstract class <asdlCodeRoot.name> {

    /**
     * All definitions in this module implement this interface to
     * support a generic approach to walking the tree.
     */
    public interface Node {
        /**
         * Allows a \<code>Visitor\</code> to visit this \<code>Node\</code>
         * without knowing its exact type. The \<code>Node\</code> dispatches
         * to the appropriate type-specific method of the visitor.
         */
        default \<T> T accept(Visitor\<T> visitor){
            return null;
        }
        /**
         * Collects all the non-null children (members and attributes)
         * of this \<code>Node\</code> whose type is defined in this module.
         */
        default java.util.Collection\<Node> children() {
            return java.util.Collections.emptyList();
        }
    }

    <asdlCodeRoot.defs: definition(); separator="\n\n">

    public interface Visitor\<T> {
        <asdlCodeRoot.defs: definitionVisit(); separator="\n">
    }

    /**
     * Base class Visitor on the AST, where each method traverses the nodes
     * using {@link Node#accept(Visitor)}, returning the last
     * non-\<code>null\</code> result of any child node. Generated leaf nodes
     * all return \<code>null\</code>, so the return from any visit is that
     * from the last "user-defined" visit method.
     */
    public static class AbstractVisitor\<T> implements Visitor\<T> {

         /**
          * Stores the last non-null value given to {@link #setTop()} or
          * returned by {@link #exit()}.
          */
        private T top = null;

        /** A stack where the top element is the last non-null result. */
        private java.util.LinkedList\<T> stack = new java.util.LinkedList\<>();

        /** If argument not null, overwrite the top of the stack (no push). */
        protected final void setTop(T t) { if (t != null) { top = t; } };

        /** Get the value at the top of the stack (no pop). */
        protected final T getTop() { return top; }

        /**
         * Call at the start of each visit method where {@link #exit()} is
         * used.
         */
        protected void enter() { stack.push(top); top = null; }

        /**
         * Call at the very end of each visit method to return the last
         * non-\<code>null\</code> result generated by any visit method
         * since {@link #enter()}.
         */
        protected T exit() {
            T t = getTop();
            top = stack.pop();
            return t;
        }

        /**
         * Visit node if not null. Use only with ({@link #enter()} and
         * {@link #exit()}.
         */
        protected void visitIfNotNull(Node node) {
            if (node != null) { setTop(node.accept(this)); }
        }

        /**
         * Visit all non-null nodes in some collection. Use only with
         * ({@link #enter()}.
         */
        protected void visitAll(java.util.Collection\<? extends Node> nodes) {
            for (Node node : nodes) { visitIfNotNull(node); }
        }

        <asdlCodeRoot.defs: definitionAbsVisitMethods()>
    }

}
>>

// ---------------------------------------------------------------------------
// Node class declaration
// ---------------------------------------------------------------------------

definition(def) ::= <<
<if(def.sum)>
<if(def.simple)><simpleSumDef(def)>
<else><sumDef(def)>
<endif>
<else><productDef(def)>
<endif>
>>

// Declaration of Node class when definition is a product.
productDef(prod) ::= <<
public static class <prod.name><if(param.javaNode)> extends <param.javaNode><endif> implements Node {
    <prod.members: memberDeclaration(); separator="\n">
    <prod.attributes: memberDeclaration(); separator="\n">

    <constructor(prod.name, [prod.members, prod.attributes])>

    <children([prod.members, prod.attributes])>

    public \<T> T accept(Visitor\<T> visitor) {
        return visitor.visit_<prod.name>(this);
    }
}
>>

constructor(name, args) ::=<<
<constructorHead(name, args)> {
    <args: memberInitStmt(); separator="\n">
}
>>

memberInitStmt(m) ::= "this.<m.name> = <m.name>;"

memberDeclaration(field) ::= <%
    public <declaredType(field)><" ">
    <field.name>;
%>

// Choose object or collection type according to cardinality
declaredType(field) ::= <%
<if(field.optional)>
    <asdlTypeToJavaObjectType.(field.type.name)>
<elseif(field.sequence)>
    java.util.List\<<asdlTypeToJavaObjectType.(field.type.name)>>
<else>
    <asdlTypeToJava.(field.type.name)>
<endif>
%>

// Emit the implementation of Node::children()
children(members) ::= <<
<if(members)>
@Override
public java.util.Collection\<Node> children() {
    java.util.List\<Node> list = new java.util.LinkedList\<>();
    <members: childrenAdd(); separator="\n">
    return list;
}
<endif>
>>

childrenAdd(field) ::= <%
<if(field.type.simple)>
    // <field.name> has non-Node type <field.type.name>
<elseif(field.optional)>
    if (<field.name>!=null) list.add(<field.name>);
<elseif(field.sequence)>
    list.addAll(<field.name>);
<else>
    list.add(<field.name>);
<endif>
%>

// Declaration of Node class when definition is a simple sum.
simpleSumDef(sum) ::= <%
public enum <sum.name><if(!sum.simple)> implements Node<endif> {
    <sum.constructors: {c|<c.name>}; separator=", ">
}
%>

// Declaration of Node class when definition is a sum.
sumDef(sum) ::= <<
public static abstract class <sum.name><if(param.javaNode)> extends <param.javaNode><endif> implements Node {

    <sum.constructors: constructorType(sum); separator="\n\n">

    <sum.attributes: memberDeclaration(); separator="\n">
    <if(sum.attributes)>

    <constructor(sum.name, sum.attributes)>
    <endif>
}
>>

// One alternative within a sum type definition
constructorType(con, def) ::= <<
public static class <con.name> extends <def.name> {
    <con.members: memberDeclaration(); separator="\n">
    <constructorHead(con.name, [con.members, def.attributes])>{
        super(<def.attributes: {m|<m.name>}; separator=", ">);
        <con.members: memberInitStmt(); separator="\n">
    }

    <children([con.members, def.attributes])>
    @Override
    public \<T> T accept(Visitor\<T> visitor) {
        return visitor.visit_<con.name>(this);
    }
}
>>

constructorHead(name, args) ::= <%
    public <name>(
    <args: argDecl(); separator=", ">
    )
%>

// Declaration of a field argument (for constructors)
argDecl(field) ::= "<declaredType(field)> <field.name>"

// ---------------------------------------------------------------------------
// Visitor interface declaration of methods
// ---------------------------------------------------------------------------

// Generate visit method(s) for a Definition
definitionVisit(def) ::= <<
<if(def.sum)>
<if(def.simple)>// Not a Node, omit: <simpleSumDefVisit(def)>
<else><sumDefVisit(def)>
<endif>
<else><productDefVisit(def)>
<endif>
>>

// Declaration of visit method when definition is a product.
productDefVisit(prod) ::= <<
default T visit_<prod.name>(<prod.name> _<prod.name>) { return null; }
>>

// Declaration of visit method when definition is a simple sum.
simpleSumDefVisit(sum) ::= <<
T visit_<sum.name>(<sum.name> _<sum.name>);
>>

// Declaration of visit method when definition is a sum.
sumDefVisit(sum) ::= <<
<sum.constructors: constructorTypeVisit(sum); separator="\n">
>>

// Visit one alternative within a sum type definition
constructorTypeVisit(con, def) ::= <<
default T visit_<con.name>(<def.name>.<con.name> _<con.name>) { return null; }
>>

// ---------------------------------------------------------------------------
// Abstract visitor implementation of methods
// ---------------------------------------------------------------------------


// Default visit method(s) for a Definition but not a simple enum
definitionAbsVisitMethods(def) ::= <%
<if(def.sum)>
    <if(!def.simple)><sumAbsVisitMethod(def)><\n><endif>
<else>
    <productAbsVisitMethod(def)><\n>
<endif>
%>

// Default visit methods when definition is a sum.
sumAbsVisitMethod(sum) ::= <%
    <sum.constructors: constructorAbsVisitMethod(sum); separator="\n"><\n>
%>

// Default visit method when definition is a product.
productAbsVisitMethod(prod) ::= <<
public T visit_<prod.name>(<prod.name> _<prod.name>) {
    enter();
    <prod.members: memberAbsVisit(prod); separator="\n">
    return exit();
}
>>

memberAbsVisit(field, def) ::= <%
    <if(field.type.simple)>
        // _<def.name>.<field.name> is not a node
    <else>
        <if(field.optional)>
            visitIfNotNull(_<def.name>.<field.name>);
        <elseif(field.sequence)>
            visitAll(_<def.name>.<field.name>);
        <else>
            setTop(_<def.name>.<field.name>.accept(this));
        <endif>
    <endif>
%>

// Default visit method within a sum type definition
constructorAbsVisitMethod(con, def) ::= <<
public T visit_<con.name>(<def.name>.<con.name> _<con.name>) {
    enter();
    <con.members: memberAbsVisit(con); separator="\n">
    return exit();
}
>>

