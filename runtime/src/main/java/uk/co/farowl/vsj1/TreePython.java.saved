package uk.co.farowl.vsj1;
// Generated by Compile
// Generated from C:\Users\Jeff\Documents\Eclipse\very-slow-jython\local\\asdl\TreePython.asdl
//

/**
 * Outer class scoping the types defined in the ASDL
 * file:   <code>C:\Users\Jeff\Documents\Eclipse\very-slow-jython\local\\asdl\TreePython.asdl</code>,
 * module: <code>TreePython</code>.
 */
public abstract class TreePython {

    /**
     * All definitions in this module implement this interface to
     * support a generic approach to walking the tree.
     */
    public interface Node {
        /**
         * Allows a <code>Visitor</code> to visit this <code>Node</code>
         * without knowing its exact type. The <code>Node</code> dispatches
         * to the appropriate type-specific method of the visitor.
         */
        <T> T accept(Visitor<T> visitor);
    }

    public static abstract class mod extends ExecNode implements Node {

        public static class Module extends mod {
            public java.util.List<stmt> body;
            public Module(java.util.List<stmt> body){
                this.body = body;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Module(this);
            }
        }

    }

    public static abstract class stmt extends ExecNode implements Node {

        public static class FunctionDef extends stmt {
            public String name;
            public arguments args;
            public java.util.List<stmt> body;
            public java.util.List<expr> decorator_list;
            public expr returns;
            public FunctionDef(String name, arguments args, java.util.List<stmt> body, java.util.List<expr> decorator_list, expr returns){
                this.name = name;
                this.args = args;
                this.body = body;
                this.decorator_list = decorator_list;
                this.returns = returns;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_FunctionDef(this);
            }
        }

        public static class Return extends stmt {
            public expr value;
            public Return(expr value){
                this.value = value;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Return(this);
            }
        }

        public static class Delete extends stmt {
            public java.util.List<expr> targets;
            public Delete(java.util.List<expr> targets){
                this.targets = targets;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Delete(this);
            }
        }

        public static class Assign extends stmt {
            public java.util.List<expr> targets;
            public expr value;
            public Assign(java.util.List<expr> targets, expr value){
                this.targets = targets;
                this.value = value;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Assign(this);
            }
        }

        public static class Global extends stmt {
            public java.util.List<String> names;
            public Global(java.util.List<String> names){
                this.names = names;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Global(this);
            }
        }

        public static class Nonlocal extends stmt {
            public java.util.List<String> names;
            public Nonlocal(java.util.List<String> names){
                this.names = names;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Nonlocal(this);
            }
        }

        public static class Expr extends stmt {
            public expr value;
            public Expr(expr value){
                this.value = value;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Expr(this);
            }
        }

        public static class Pass extends stmt {
            public Pass(){
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Pass(this);
            }
        }

    }

    public static abstract class expr extends ExecNode implements Node {

        public static class BinOp extends expr {
            public expr left;
            public operator op;
            public expr right;
            public BinOp(expr left, operator op, expr right){
                this.left = left;
                this.op = op;
                this.right = right;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_BinOp(this);
            }
        }

        public static class UnaryOp extends expr {
            public unaryop op;
            public expr operand;
            public UnaryOp(unaryop op, expr operand){
                this.op = op;
                this.operand = operand;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_UnaryOp(this);
            }
        }

        public static class Call extends expr {
            public expr func;
            public java.util.List<expr> args;
            public java.util.List<keyword> keywords;
            public Call(expr func, java.util.List<expr> args, java.util.List<keyword> keywords){
                this.func = func;
                this.args = args;
                this.keywords = keywords;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Call(this);
            }
        }

        public static class Num extends expr {
            public Object n;
            public Num(Object n){
                this.n = n;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Num(this);
            }
        }

        public static class Str extends expr {
            public String s;
            public Str(String s){
                this.s = s;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Str(this);
            }
        }

        public static class Name extends expr {
            public String id;
            public expr_context ctx;
            public Name(String id, expr_context ctx){
                this.id = id;
                this.ctx = ctx;
            }

            public <T> T accept(Visitor<T> visitor) {
                return visitor.visit_Name(this);
            }
        }

    }

    public enum operator {Add, Sub, Mult, Div}

    public enum unaryop {UAdd, USub}

    public enum expr_context {Load, Store, Del}

    public static class arguments extends ExecNode implements Node {
        public java.util.List<arg> args;
        public arg vararg;
        public java.util.List<arg> kwonlyargs;
        public java.util.List<expr> kw_defaults;
        public arg kwarg;
        public java.util.List<expr> defaults;

        public arguments(java.util.List<arg> args, arg vararg, java.util.List<arg> kwonlyargs, java.util.List<expr> kw_defaults, arg kwarg, java.util.List<expr> defaults) {
            this.args = args;
            this.vararg = vararg;
            this.kwonlyargs = kwonlyargs;
            this.kw_defaults = kw_defaults;
            this.kwarg = kwarg;
            this.defaults = defaults;
        }

        public <T> T accept(Visitor<T> visitor) {
            return visitor.visit_arguments(this);
        }
    }

    public static class arg extends ExecNode implements Node {
        public String arg;
        public expr annotation;

        public arg(String arg, expr annotation) {
            this.arg = arg;
            this.annotation = annotation;
        }

        public <T> T accept(Visitor<T> visitor) {
            return visitor.visit_arg(this);
        }
    }

    public static class keyword extends ExecNode implements Node {
        public String arg;
        public expr value;

        public keyword(String arg, expr value) {
            this.arg = arg;
            this.value = value;
        }

        public <T> T accept(Visitor<T> visitor) {
            return visitor.visit_keyword(this);
        }
    }


    /** Visitor interface on the AST. */
    public interface Visitor<T> {
        default T visit_Module(mod.Module _Module){ return null; }
        default T visit_FunctionDef(stmt.FunctionDef _FunctionDef){ return null; }
        default T visit_Return(stmt.Return _Return){ return null; }
        default T visit_Delete(stmt.Delete _Delete){ return null; }
        default T visit_Assign(stmt.Assign _Assign){ return null; }
        default T visit_Global(stmt.Global _Global){ return null; }
        default T visit_Nonlocal(stmt.Nonlocal _Nonlocal){ return null; }
        default T visit_Expr(stmt.Expr _Expr){ return null; }
        default T visit_Pass(stmt.Pass _Pass){ return null; }
        default T visit_BinOp(expr.BinOp _BinOp){ return null; }
        default T visit_UnaryOp(expr.UnaryOp _UnaryOp){ return null; }
        default T visit_Call(expr.Call _Call){ return null; }
        default T visit_Num(expr.Num _Num){ return null; }
        default T visit_Str(expr.Str _Str){ return null; }
        default T visit_Name(expr.Name _Name){ return null; }
        default T visit_arguments(arguments _arguments){ return null; }
        default T visit_arg(arg _arg){ return null; }
        default T visit_keyword(keyword _keyword){ return null; }

    }

    /**
     * Base class Visitor on the AST, where each method traverses the nodes
     * using {@link Node#accept(Visitor)}, returning the last
     * non-<code>null</code> result of any child node. Generated leaf nodes
     * all return <code>null</code>, so the return from any visit is that
     * from the last "user-defined" visit method.
     */
    public static class AbstractVisitor<T> implements Visitor<T> {

         /**
          * Stores the last non-null value given to {@link #setTop()} or
          * returned by {@link #exit()}.
          */
        private T top = null;

        /** A stack where the top element is the last non-null result. */
        private java.util.LinkedList<T> stack = new java.util.LinkedList<>();

        /** If argument not null, overwrite the top of the stack (no push). */
        protected final void setTop(T t) { if (t != null) { top = t; } };

        /** Get the value at the top of the stack (no pop). */
        protected final T getTop() { return top; }

        /**
         * Call at the start of each visit method where {@link #exit()} is
         * used.
         */
        protected void enter() { stack.push(top); top = null; }

        /**
         * Call at the very end of each visit method to return the last
         * non-<code>null</code> result generated by any visit method
         * since {@link #enter()}.
         */
        protected T exit() {
            T t = getTop();
            top = stack.pop();
            return t;
        }

        /**
         * Visit node if not null. Use only with ({@link #enter()} and
         * {@link #exit()}.
         */
        protected void visitIfNotNull(Node node) {
            if (node != null) { setTop(node.accept(this)); }
        }

        /**
         * Visit all non-null nodes in some collection. Use only with
         * ({@link #enter()}.
         */
        protected void visitAll(java.util.Collection<? extends Node> nodes) {
            for (Node node : nodes) { visitIfNotNull(node); }
        }

        public T visit_Module(mod.Module _Module) {
            enter();
            visitAll(_Module.body);
            return exit();
        }

        public T visit_FunctionDef(stmt.FunctionDef _FunctionDef) {
            enter();
            // _FunctionDef.name is not a node
            setTop(_FunctionDef.args.accept(this));
            visitAll(_FunctionDef.body);
            visitAll(_FunctionDef.decorator_list);
            visitIfNotNull(_FunctionDef.returns);
            return exit();
        }
        public T visit_Return(stmt.Return _Return) {
            enter();
            visitIfNotNull(_Return.value);
            return exit();
        }
        public T visit_Delete(stmt.Delete _Delete) {
            enter();
            visitAll(_Delete.targets);
            return exit();
        }
        public T visit_Assign(stmt.Assign _Assign) {
            enter();
            visitAll(_Assign.targets);
            setTop(_Assign.value.accept(this));
            return exit();
        }
        public T visit_Global(stmt.Global _Global) {
            enter();
            // _Global.names is not a node
            return exit();
        }
        public T visit_Nonlocal(stmt.Nonlocal _Nonlocal) {
            enter();
            // _Nonlocal.names is not a node
            return exit();
        }
        public T visit_Expr(stmt.Expr _Expr) {
            enter();
            setTop(_Expr.value.accept(this));
            return exit();
        }
        public T visit_Pass(stmt.Pass _Pass) {
            enter();
            return exit();
        }

        public T visit_BinOp(expr.BinOp _BinOp) {
            enter();
            setTop(_BinOp.left.accept(this));
            // _BinOp.op is not a node
            setTop(_BinOp.right.accept(this));
            return exit();
        }
        public T visit_UnaryOp(expr.UnaryOp _UnaryOp) {
            enter();
            // _UnaryOp.op is not a node
            setTop(_UnaryOp.operand.accept(this));
            return exit();
        }
        public T visit_Call(expr.Call _Call) {
            enter();
            setTop(_Call.func.accept(this));
            visitAll(_Call.args);
            visitAll(_Call.keywords);
            return exit();
        }
        public T visit_Num(expr.Num _Num) {
            enter();
            // _Num.n is not a node
            return exit();
        }
        public T visit_Str(expr.Str _Str) {
            enter();
            // _Str.s is not a node
            return exit();
        }
        public T visit_Name(expr.Name _Name) {
            enter();
            // _Name.id is not a node
            // _Name.ctx is not a node
            return exit();
        }

        public T visit_arguments(arguments _arguments) {
            enter();
            visitAll(_arguments.args);
            visitIfNotNull(_arguments.vararg);
            visitAll(_arguments.kwonlyargs);
            visitAll(_arguments.kw_defaults);
            visitIfNotNull(_arguments.kwarg);
            visitAll(_arguments.defaults);
            return exit();
        }
        public T visit_arg(arg _arg) {
            enter();
            // _arg.arg is not a node
            visitIfNotNull(_arg.annotation);
            return exit();
        }
        public T visit_keyword(keyword _keyword) {
            enter();
            // _keyword.arg is not a node
            setTop(_keyword.value.accept(this));
            return exit();
        }

    }

}
